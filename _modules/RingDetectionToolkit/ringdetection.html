<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RingDetectionToolkit.ringdetection &mdash; RingDetection 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=8d563738"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            RingDetection
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../main.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../RingDetection.html">Ring Detection documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">RingDetection</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">RingDetectionToolkit.ringdetection</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for RingDetectionToolkit.ringdetection</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2025 a.fiorentino4@studenti.unipi.it</span>
<span class="c1"># For license terms see LICENSE file.</span>
<span class="c1">#</span>
<span class="c1"># SPDX-License-Identifier: GPL-2.0-or-later</span>
<span class="c1">#</span>
<span class="c1"># This program is free software under GPLv2+</span>
<span class="c1"># See https://www.gnu.org/licenses/gpl-2.0.html</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Ring Detection and Analysis Toolkit</span>

<span class="sd">This comprehensive module provides all core functionality for:</span>

<span class="sd">- Synthetic data generation and simulation</span>
<span class="sd">- Adaptive clustering algorithms</span>
<span class="sd">- Circle fitting and geometric analysis</span>
<span class="sd">- Visualization and reporting tools</span>
<span class="sd">- Performance evaluation and metrics</span>
<span class="sd">- Core algorithms for adaptive ring detection</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="c1"># ============================ IMPORTS ============================ #</span>
<span class="c1"># Standard library imports</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Iterable</span>

<span class="c1"># Third-party imports</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">DBSCAN</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">least_squares</span>

<span class="c1"># ============================ CONSTANTS ============================ #</span>

<span class="n">DEBUG</span> <span class="o">=</span> <span class="kc">False</span>           <span class="c1"># Global debug flag for additional output</span>

<span class="c1"># -------------------- RING GENERATION PARAMETERS -------------------- #</span>
<span class="n">NUM_RINGS</span> <span class="o">=</span> <span class="mi">3</span>                <span class="c1"># Default number of rings to generate</span>
<span class="n">X_MIN</span><span class="p">,</span> <span class="n">X_MAX</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span>      <span class="c1"># X-coordinate bounds for circle centers</span>
<span class="n">Y_MIN</span><span class="p">,</span> <span class="n">Y_MAX</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span>      <span class="c1"># Y-coordinate bounds for circle centers</span>
<span class="n">R_MIN</span><span class="p">,</span> <span class="n">R_MAX</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span>  <span class="c1"># Radius bounds for generated circles</span>
<span class="n">POINTS_PER_RING</span> <span class="o">=</span> <span class="mi">500</span>        <span class="c1"># Points per generated ring</span>
<span class="n">RADIUS_SCATTER</span> <span class="o">=</span> <span class="mf">0.01</span>        <span class="c1"># Scatter level for generated points</span>

<span class="c1"># -------------------- CLUSTERING PARAMETERS -------------------- #</span>

<span class="c1"># Local constants</span>
<span class="n">MIN_DBSCAN_EPS</span> <span class="o">=</span> <span class="mf">1e-3</span>   <span class="c1"># Minimum DBSCAN eps</span>
<span class="n">MAX_DBSCAN_EPS</span> <span class="o">=</span> <span class="mi">1</span>      <span class="c1"># Maximum DBSCAN eps</span>

<span class="c1"># Min max clusters per ring</span>
<span class="n">MIN_CLUSTERS_PER_RING</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># Minimum number of clusters per ring</span>
<span class="n">MAX_CLUSTERS_PER_RING</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># Maximum number of clusters per ring</span>

<span class="c1"># Compute total minimum and maximum clusters across all rings</span>
<span class="n">MIN_CLUSTERS</span> <span class="o">=</span> <span class="n">MIN_CLUSTERS_PER_RING</span> <span class="o">*</span> <span class="n">NUM_RINGS</span>  <span class="c1"># Total minimum clusters</span>
<span class="n">MAX_CLUSTERS</span> <span class="o">=</span> <span class="n">MAX_CLUSTERS_PER_RING</span> <span class="o">*</span> <span class="n">NUM_RINGS</span>  <span class="c1"># Total maximum clusters</span>
<span class="n">MIN_SAMPLES</span> <span class="o">=</span> <span class="mi">7</span>  <span class="c1"># Minimum number of samples for clustering (DBSCAN parameter)</span>

<span class="c1"># -------------------- THRESHOLD Parameters -------------------- #</span>
<span class="n">SIGMA_THRESHOLD_RM</span> <span class="o">=</span> <span class="mf">2.0</span>     <span class="c1"># Sigma threshold for merging similar rings</span>
<span class="n">SIGMA_THRESHOLD</span> <span class="o">=</span> <span class="mf">2.0</span>        <span class="c1"># Sigma threshold for extracting the best ring</span>
<span class="n">S_SCALE</span> <span class="o">=</span> <span class="mf">1.8</span>                <span class="c1"># Scaling factor for sigma threshold relaxation</span>
<span class="n">FITTING_PAIR_TRESHOLD</span> <span class="o">=</span> <span class="mi">20</span>   <span class="c1"># Threshold for matching found-to-original rings</span>


<span class="c1"># ============================ EXPORT LIST ============================ #</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># Visualization</span>
    <span class="s1">&#39;print_circle&#39;</span><span class="p">,</span>
    <span class="s1">&#39;print_circles&#39;</span><span class="p">,</span>
    <span class="s1">&#39;calculate_and_print_statistics&#39;</span><span class="p">,</span>
    <span class="s1">&#39;get_color&#39;</span><span class="p">,</span>
    <span class="s1">&#39;plot_commons&#39;</span><span class="p">,</span>
    <span class="s1">&#39;plot_points_base&#39;</span><span class="p">,</span>
    <span class="s1">&#39;plot_points&#39;</span><span class="p">,</span>
    <span class="s1">&#39;plot_circle&#39;</span><span class="p">,</span>
    <span class="s1">&#39;plot_circles&#39;</span><span class="p">,</span>
    <span class="s1">&#39;plot_ratii_histograms&#39;</span><span class="p">,</span>
    <span class="s1">&#39;show_dictionary&#39;</span><span class="p">,</span>

    <span class="c1"># Quality Assessment</span>
    <span class="s1">&#39;is_a_good_circle&#39;</span><span class="p">,</span>

    <span class="c1"># Data Generation</span>
    <span class="s1">&#39;generate_circles&#39;</span><span class="p">,</span>
    <span class="s1">&#39;generate_rings_complete&#39;</span><span class="p">,</span>
    <span class="s1">&#39;generate_rings_complete_vectorized&#39;</span><span class="p">,</span>

    <span class="c1"># Circle Fitting</span>
    <span class="s1">&#39;fit_circle_to_points&#39;</span><span class="p">,</span>
    <span class="s1">&#39;fit_circle_to_points_fast&#39;</span><span class="p">,</span>
    <span class="s1">&#39;fit_circles_to_clusters&#39;</span><span class="p">,</span>
    <span class="s1">&#39;fit_circles_to_clusters_fast&#39;</span><span class="p">,</span>

    <span class="c1"># Clustering</span>
    <span class="s1">&#39;filter_labels&#39;</span><span class="p">,</span>
    <span class="s1">&#39;adaptive_clustering&#39;</span><span class="p">,</span>
    <span class="s1">&#39;create_cluster_dict&#39;</span><span class="p">,</span>
    <span class="s1">&#39;filter_fitted_clusters&#39;</span><span class="p">,</span>
    <span class="s1">&#39;compatible_clusters&#39;</span><span class="p">,</span>
    <span class="s1">&#39;compare_and_merge_clusters&#39;</span><span class="p">,</span>

    <span class="c1"># Point Extraction</span>
    <span class="s1">&#39;extract_points&#39;</span><span class="p">,</span>
    <span class="s1">&#39;extract_best_ring&#39;</span><span class="p">,</span>
    <span class="s1">&#39;exclude_outliers&#39;</span><span class="p">,</span>

    <span class="c1"># Evaluation</span>
    <span class="s1">&#39;calculate_ratii&#39;</span><span class="p">,</span>
    <span class="s1">&#39;find_fitting_pairs&#39;</span><span class="p">,</span>
    <span class="s1">&#39;analyze_ratii_efficiency&#39;</span><span class="p">,</span>
    <span class="s1">&#39;find_nearest_circle&#39;</span><span class="p">,</span>
    <span class="s1">&#39;evaluate_fit_comparability&#39;</span><span class="p">,</span>

    <span class="c1"># Main procedures</span>
    <span class="s1">&#39;main_procedure_adaptive&#39;</span><span class="p">,</span>
    <span class="s1">&#39;main_procedure&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="c1"># ============================ TEXT REPORTING ============================ #</span>

<div class="viewcode-block" id="print_circle">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.print_circle">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">print_circle</span><span class="p">(</span><span class="n">circle</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
                 <span class="n">errors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">title</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">rmse</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prints the details of a circle, including its center, radius, errors (if provided),</span>
<span class="sd">    and RMSE (if provided).</span>

<span class="sd">    Args:</span>
<span class="sd">        circle (np.ndarray): A NumPy array representing the circle as [x, y, r], where:</span>

<span class="sd">                             - x, y are the coordinates of the center.</span>
<span class="sd">                             - r is the radius.</span>
<span class="sd">        errors (np.ndarray, optional): A NumPy array representing the errors as:</span>
<span class="sd">            [err_x, err_y, err_r].</span>
<span class="sd">        title (str, optional): A title to print before the circle details.</span>
<span class="sd">        label (str, optional): A label to prepend to the circle details (e.g., &quot;Cluster 1&quot;).</span>
<span class="sd">        rmse (float, optional): The Root Mean Square Error (RMSE).</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the length of the errors array does not match the length of the circle array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Input validation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">circle</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">circle</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Circle must be a NumPy array of shape (3,): [x, y, r].&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">errors</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">errors</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Errors must be a NumPy array of shape (3,): [err_x, err_y, err_r].&quot;</span><span class="p">)</span>

    <span class="c1"># Print the title if provided</span>
    <span class="k">if</span> <span class="n">title</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

    <span class="c1"># Print the label if provided, using efficient formatting</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">: &#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">label</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="c1"># Print the circle details with errors (if provided)</span>
    <span class="k">if</span> <span class="n">errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Center = (</span><span class="si">{</span><span class="n">circle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> ± </span><span class="si">{</span><span class="n">errors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">circle</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> ± </span><span class="si">{</span><span class="n">errors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">), &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Radius = </span><span class="si">{</span><span class="n">circle</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> ± </span><span class="si">{</span><span class="n">errors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="sa">f</span><span class="s1">&#39;, RMSE: </span><span class="si">{</span><span class="n">rmse</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">rmse</span><span class="w"> </span><span class="ow">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="kc">None</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Center = (</span><span class="si">{</span><span class="n">circle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">circle</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">), &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Radius = </span><span class="si">{</span><span class="n">circle</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="sa">f</span><span class="s1">&#39;, RMSE: </span><span class="si">{</span><span class="n">rmse</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">rmse</span><span class="w"> </span><span class="ow">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="kc">None</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="print_circles">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.print_circles">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">print_circles</span><span class="p">(</span><span class="n">circles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">errors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">title</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">enum</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">rmse</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Print details for multiple circles, including their centers, radii,</span>
<span class="sd">    and optional errors and RMSE.</span>

<span class="sd">    This function generalizes &#39;print_circle&#39; to handle multiple circles.</span>
<span class="sd">    The &#39;enum&#39; argument can be used to provide custom enumeration labels</span>
<span class="sd">    for each circle. If &#39;enum&#39; is not provided, circles are enumerated</span>
<span class="sd">    from 0 to n-1.</span>

<span class="sd">    Args:</span>
<span class="sd">        circles (np.ndarray): A NumPy array of circles,</span>
<span class="sd">            where each circle is represented as [x, y, r].</span>
<span class="sd">        errors (Optional[np.ndarray]): A NumPy array of errors, where each row is:</span>
<span class="sd">            [err_x, err_y, err_r]. Defaults to None.</span>
<span class="sd">        title (Optional[str]): A title to print before the circle details. Defaults to None.</span>
<span class="sd">        label (Optional[str]): A label to prepend to each circle&#39;s details (e.g., &quot;Cluster&quot;).</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        enum (Optional[np.ndarray]): A NumPy array of custom enumeration labels for each circle.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        rmse (Optional[np.ndarray]): A NumPy array of RMSE values for each circle. Defaults to None.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the input arrays have incorrect shapes or lengths. Then,</span>
<span class="sd">        if the lengths of &#39;errors&#39;, &#39;rmse&#39;, or &#39;enum&#39; do not match the number of circles.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">circles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Circles must be a NumPy array of shape (3,) or (N, 3): [x, y, r].&quot;</span><span class="p">)</span>

    <span class="c1"># If &#39;errors&#39; is provided, ensure it has the same shape as &#39;circles&#39;</span>
    <span class="k">if</span> <span class="n">errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">errors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Errors must be a NumPy array of the same shape as circles: (N, 3).&quot;</span><span class="p">)</span>

    <span class="c1"># Validate the length of rmse if provided</span>
    <span class="k">if</span> <span class="n">rmse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">rmse</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of the rmse array must match the number of circles.&quot;</span><span class="p">)</span>

    <span class="c1"># If enum is not provided, generate default enumeration</span>
    <span class="k">if</span> <span class="n">enum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">enum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">))</span>  <span class="c1"># Use NumPy array for enumeration</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">enum</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of the enum array must match the number of circles.&quot;</span><span class="p">)</span>

    <span class="c1"># Print the title if provided</span>
    <span class="k">if</span> <span class="n">title</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

    <span class="c1"># Iterate over the circles and print each one</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">circle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">circles</span><span class="p">):</span>
        <span class="c1"># Get the errors and RMSE for the current circle (if provided)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">errors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">rmse_value</span> <span class="o">=</span> <span class="n">rmse</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">rmse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Determine the label for the current circle</span>
        <span class="n">enum_label</span> <span class="o">=</span> <span class="n">enum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">lbl</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">enum_label</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">label</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">enum_label</span><span class="p">)</span>

        <span class="c1"># Print the circle using the print_circle function</span>
        <span class="n">print_circle</span><span class="p">(</span><span class="n">circle</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">err</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">lbl</span><span class="p">,</span> <span class="n">rmse</span><span class="o">=</span><span class="n">rmse_value</span><span class="p">)</span></div>


<div class="viewcode-block" id="calculate_and_print_statistics">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.calculate_and_print_statistics">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_and_print_statistics</span><span class="p">(</span><span class="n">ratii_x_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                   <span class="n">ratii_y_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                   <span class="n">ratii_r_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates and prints the average (mean), standard deviation,</span>
<span class="sd">    and standard error of the mean (SEM) for ratii_x, ratii_y, and ratii_r.</span>

<span class="sd">    Args:</span>
<span class="sd">        ratii_x_array (np.ndarray): Array of ratio_x values.</span>
<span class="sd">        ratii_y_array (np.ndarray): Array of ratio_y values.</span>
<span class="sd">        ratii_r_array (np.ndarray): Array of ratio_r values.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the lengths of the input arrays are not the same.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if the lengths of the input arrays are the same</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ratii_x_array</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ratii_y_array</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">ratii_x_array</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ratii_r_array</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The lengths of ratii_x, ratii_y, and ratii_r must be the same.&quot;</span><span class="p">)</span>

    <span class="c1"># Calculate the number of samples</span>
    <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ratii_x_array</span><span class="p">)</span>

    <span class="c1"># Calculate mean and standard deviation for each array</span>
    <span class="n">mean_x</span><span class="p">,</span> <span class="n">std_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratii_x_array</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ratii_x_array</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">mean_y</span><span class="p">,</span> <span class="n">std_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratii_y_array</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ratii_y_array</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">mean_r</span><span class="p">,</span> <span class="n">std_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratii_r_array</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ratii_r_array</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Calculate standard error of the mean (SEM)</span>
    <span class="n">sem_x</span> <span class="o">=</span> <span class="n">std_x</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
    <span class="n">sem_y</span> <span class="o">=</span> <span class="n">std_y</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
    <span class="n">sem_r</span> <span class="o">=</span> <span class="n">std_r</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>

    <span class="c1"># Print the results</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Statistics for Ratii:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ratio X: Mean = </span><span class="si">{</span><span class="n">mean_x</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, Std Dev = </span><span class="si">{</span><span class="n">std_x</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, SEM = </span><span class="si">{</span><span class="n">sem_x</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ratio Y: Mean = </span><span class="si">{</span><span class="n">mean_y</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, Std Dev = </span><span class="si">{</span><span class="n">std_y</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, SEM = </span><span class="si">{</span><span class="n">sem_y</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ratio R: Mean = </span><span class="si">{</span><span class="n">mean_r</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, Std Dev = </span><span class="si">{</span><span class="n">std_r</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, SEM = </span><span class="si">{</span><span class="n">sem_r</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<span class="c1"># =========================== COLOR MANAGEMENT =========================== #</span>

<div class="viewcode-block" id="get_color">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.get_color">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_color</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmap_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;jet&quot;</span><span class="p">,</span>
              <span class="n">num_distinct_colors</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a color from a specified colormap based on an index. Ensures distinct colors</span>
<span class="sd">    for the first &#39;num_distinct_colors&#39; indices and cycles through the colormap for larger indices.</span>

<span class="sd">    Args:</span>
<span class="sd">        index (int, optional): An index to determine the color. If negative,</span>
<span class="sd">            the function cycles through the colormap.</span>
<span class="sd">        cmap_name (str, optional): Name of the colormap to use (default: &quot;jet&quot;).</span>
<span class="sd">        num_distinct_colors (int, optional): Number of distinct colors to ensure for</span>
<span class="sd">            small indices (default: 15).</span>

<span class="sd">    Returns:</span>
<span class="sd">        - tuple: An RGBA color tuple, where each value is in the range [0, 1].</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If &#39;num_distinct_colors&#39; is less than 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num_distinct_colors</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_distinct_colors must be at least 1.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">get_color</span><span class="p">,</span> <span class="s2">&quot;cmap&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">get_color</span><span class="o">.</span><span class="n">cmap</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">cmap_name</span><span class="p">:</span>
        <span class="c1"># Initialize or update the colormap if it doesn&#39;t exist or if the name has changed</span>
        <span class="n">get_color</span><span class="o">.</span><span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap_name</span><span class="p">)</span>
        <span class="n">get_color</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Counter for cycling colors</span>

    <span class="c1"># If a specific index is given, reset the counter</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">get_color</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="n">index</span>

    <span class="c1"># Normalize the index to the range [0, 1] based on num_distinct_colors</span>
    <span class="n">normalized_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_color</span><span class="o">.</span><span class="n">counter</span> <span class="o">%</span> <span class="n">num_distinct_colors</span>
                        <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_distinct_colors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># to avoid cycling</span>

    <span class="c1"># Update counter for the next call</span>
    <span class="n">get_color</span><span class="o">.</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Return the corresponding color</span>
    <span class="k">return</span> <span class="n">get_color</span><span class="o">.</span><span class="n">cmap</span><span class="p">(</span><span class="n">normalized_index</span><span class="p">)</span></div>


<span class="c1"># ========================== CORE PLOTTING ========================== #</span>

<div class="viewcode-block" id="plot_commons">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.plot_commons">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">plot_commons</span><span class="p">(</span><span class="n">title</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">hold</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">legend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Common plotting settings for all plots.</span>

<span class="sd">    This function sets the aspect ratio, axis labels, tick marks,</span>
<span class="sd">    grid, bounds, and legend if specified.</span>

<span class="sd">    Args:</span>
<span class="sd">        title (str, optional): Title of the plot.</span>
<span class="sd">        bound (bool, optional): Whether to set axis limits to (0, 1) for both axes.</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        hold (bool, optional): Whether to hold the plot</span>
<span class="sd">            (if False, the plot is displayed immediately). Defaults to True.</span>
<span class="sd">        legend (bool, optional): Whether to show legend with a custom bounding box.</span>
<span class="sd">            Defaults to False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set the aspect ratio of the plot to be equal (ensures circles are not distorted)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>

    <span class="c1"># Set the labels for the x and y axes with a specified font size</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>

    <span class="c1"># Set the x and y axis tick marks at intervals of 0.1 from 0 to 1</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>

    <span class="c1"># Add a title to the plot if provided, with a larger font size and bold weight</span>
    <span class="k">if</span> <span class="n">title</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s2">&quot;bold&quot;</span><span class="p">)</span>

    <span class="c1"># Set the axis limits to (0, 1) for both x and y axes if &#39;bound&#39; is True</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Add a grid to the plot</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Add a legend to the plot if &#39;legend&#39; is True, with a custom bounding box</span>
    <span class="k">if</span> <span class="n">legend</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.04</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;center left&quot;</span><span class="p">,</span>
                   <span class="n">ncol</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">borderaxespad</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Display the plot immediately if &#39;hold&#39; is False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">hold</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<span class="c1"># =========================== POINT VISUALIZATION =========================== #</span>

<div class="viewcode-block" id="plot_points_base">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.plot_points_base">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">plot_points_base</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">hold</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots raw points with customizable options. Can also handle clustering</span>
<span class="sd">    by coloring points based on cluster labels.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (np.ndarray): A 2D NumPy array of shape (N, 2) representing the points to plot.</span>
<span class="sd">        title (Optional[str]): Title of the plot. Defaults to None.</span>
<span class="sd">        color (Optional[str]): Default color of the points. Ignored if &#39;cluster_labels&#39; is provided.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        label (Optional[str]): Label for the points (used in the legend). Defaults to None.</span>
<span class="sd">        cluster_labels (Optional[np.ndarray]): Cluster labels for each point.</span>
<span class="sd">            If provided, colors are assigned per cluster.</span>
<span class="sd">        hold (bool): Whether to hold the plot (if False, the plot is displayed immediately).</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Unpack the points into x and y coordinates</span>
    <span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Plot points with default color</span>
    <span class="n">default_color</span> <span class="o">=</span> <span class="n">color</span> <span class="k">if</span> <span class="n">color</span> <span class="k">else</span> <span class="n">get_color</span><span class="p">()</span>  <span class="c1"># Fallback color</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
        <span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
        <span class="n">color</span><span class="o">=</span><span class="n">default_color</span> <span class="k">if</span> <span class="n">color</span> <span class="k">else</span> <span class="n">get_color</span><span class="p">(),</span>
        <span class="n">s</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="c1"># Apply common plot settings</span>
    <span class="n">plot_commons</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="n">hold</span><span class="p">,</span>
                 <span class="n">legend</span><span class="o">=</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="plot_points">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.plot_points">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">plot_points</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">cluster_labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">hold</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots raw points with customizable options. Can also handle clustering</span>
<span class="sd">    by coloring points based on cluster labels.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (np.ndarray): A 2D NumPy array of shape (N, 2) representing the points to plot.</span>
<span class="sd">        title (Optional[str]): Title of the plot. Defaults to None.</span>
<span class="sd">        color (Optional[str]): Default color of the points. Ignored if &#39;cluster_labels&#39; is provided.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        label (Optional[str]): Label for the points (used in the legend). Defaults to None.</span>
<span class="sd">        cluster_labels (Optional[np.ndarray]): Cluster labels for each point.</span>
<span class="sd">            If provided, colors are assigned per cluster.</span>
<span class="sd">        hold (bool): Whether to hold the plot (if False, the plot is displayed immediately).</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Input validation</span>
    <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Points must be a 2D NumPy array of shape (N, 2).&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">cluster_labels</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cluster labels must have the same length as points.&quot;</span><span class="p">)</span>

    <span class="c1"># If cluster labels are provided, plot points with cluster colors</span>
    <span class="k">if</span> <span class="n">cluster_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">unique_labels</span><span class="p">:</span>
            <span class="c1"># Assign colors to clusters, gray for noise</span>
            <span class="n">cluster_color</span> <span class="o">=</span> <span class="s1">&#39;gray&#39;</span> <span class="k">if</span> <span class="n">lbl</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">get_color</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>
            <span class="n">cluster_points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">lbl</span><span class="p">]</span>

            <span class="n">plot_points_base</span><span class="p">(</span><span class="n">cluster_points</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="n">cluster_color</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Cluster </span><span class="si">{</span><span class="n">lbl</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">lbl</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;Noise&quot;</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Plot points with default color</span>
        <span class="n">default_color</span> <span class="o">=</span> <span class="n">color</span> <span class="k">if</span> <span class="n">color</span> <span class="k">else</span> <span class="n">get_color</span><span class="p">()</span>  <span class="c1"># Fallback color</span>
        <span class="n">plot_points_base</span><span class="p">(</span><span class="n">points</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">default_color</span> <span class="k">if</span> <span class="n">color</span> <span class="k">else</span> <span class="n">get_color</span><span class="p">(),</span>
            <span class="n">label</span><span class="o">=</span><span class="n">label</span>
        <span class="p">)</span>

    <span class="c1"># Apply common plot settings</span>
    <span class="n">plot_commons</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="n">hold</span><span class="p">,</span>
                 <span class="n">legend</span><span class="o">=</span><span class="p">(</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cluster_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">))</span></div>


<span class="c1"># =========================== CIRCLE VISUALIZATION =========================== #</span>

<div class="viewcode-block" id="plot_circle">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.plot_circle">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">plot_circle</span><span class="p">(</span><span class="n">circle</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;solid&#39;</span><span class="p">,</span>
                <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">center_as_o</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">hold</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots a single circle given as a NumPy array [x_c, y_c, radius].</span>

<span class="sd">    Args:</span>
<span class="sd">        circle (np.ndarray): A NumPy array containing the circle&#39;s center</span>
<span class="sd">            (x_c, y_c) and radius (radius).</span>
<span class="sd">        title (Optional[str]): Title of the plot. Defaults to None.</span>
<span class="sd">        color (str): Color of the circle. Defaults to &#39;blue&#39;.</span>
<span class="sd">        linestyle (str): Line style of the circle (e.g., &#39;solid&#39;, &#39;dashed&#39;). Defaults to &#39;solid&#39;.</span>
<span class="sd">        label (Optional[str]): Label for the circle (used in the legend). Defaults to None.</span>
<span class="sd">        center_as_o (bool): Whether to mark the center with &#39;o&#39; instead of &#39;+&#39;. Defaults to False.</span>
<span class="sd">        hold (bool): Whether to hold the plot (if False, the plot is displayed immediately).</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        linewidth (int): Width of the circle&#39;s edge. Defaults to 3.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Input validation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">circle</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">circle</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Circle must be a NumPy array of shape (3,): [x_c, y_c, radius].&quot;</span><span class="p">)</span>

    <span class="n">x_c</span><span class="p">,</span> <span class="n">y_c</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">circle</span>
    <span class="k">if</span> <span class="n">radius</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Radius must be a positive number.&quot;</span><span class="p">)</span>

    <span class="c1"># Create a Circle object with the specified properties</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="n">x_c</span><span class="p">,</span> <span class="n">y_c</span><span class="p">),</span> <span class="n">radius</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span>
                      <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

    <span class="c1"># Add the Circle object to the current plot</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>

    <span class="c1"># Always plot the center</span>
    <span class="n">center_marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span> <span class="k">if</span> <span class="n">center_as_o</span> <span class="k">else</span> <span class="s1">&#39;+&#39;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_c</span><span class="p">,</span> <span class="n">y_c</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">center_marker</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Apply common plot settings</span>
    <span class="n">plot_commons</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="n">hold</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="plot_circles">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.plot_circles">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">plot_circles</span><span class="p">(</span><span class="n">circles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                 <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">enum</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">center_as_o</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">hold</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">linestyle</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;solid&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots multiple circles with customizable options.</span>

<span class="sd">    Args:</span>
<span class="sd">        circles (np.ndarray): A NumPy array of circles, where each row is [x_c, y_c, radius].</span>
<span class="sd">        title (Optional[str]): Title of the plot. Defaults to None.</span>
<span class="sd">        color (Optional[str]): Default color of the circles. If None, a unique color is</span>
<span class="sd">            assigned to each circle. Defaults to None.</span>
<span class="sd">        linewidth (int): Width of the circles&#39; edges. Defaults to 3.</span>
<span class="sd">        label (Optional[str]): Base label for the circles (used in the legend). If &#39;enum&#39;</span>
<span class="sd">            is provided, the label will be appended with the enumeration value.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        enum (Optional[np.ndarray]): Custom enumeration labels for the circles.</span>
<span class="sd">            If provided, it must have the same length as &#39;circles&#39;. Defaults to None.</span>
<span class="sd">        center_as_o (bool): Whether to mark the centers with &#39;o&#39; instead of &#39;+&#39;. Defaults to False.</span>
<span class="sd">        hold (bool): Whether to hold the plot (if False, the plot is displayed immediately).</span>
<span class="sd">            Defaults to True.</span>
<span class="sd">        linestyle (Optional[str]): Line style of the circles (e.g., &#39;solid&#39;, &#39;dashed&#39;, &#39;dotted&#39;).</span>
<span class="sd">            Defaults to &#39;solid&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Input validation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">circles</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">circles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Circles must be a NumPy array of shape (N, 3): [x_c, y_c, radius].&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">circles</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All radii must be positive numbers.&quot;</span><span class="p">)</span>

    <span class="c1"># Validate enum length if provided</span>
    <span class="k">if</span> <span class="n">enum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">enum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The &#39;enum&#39; argument must be a NumPy array of enumeration labels.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">enum</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of the enum array must match the number of circles.&quot;</span><span class="p">)</span>

    <span class="c1"># Plot all circles</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">circle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">circles</span><span class="p">):</span>
        <span class="c1"># Pick a color</span>
        <span class="n">this_color</span> <span class="o">=</span> <span class="n">color</span> <span class="k">if</span> <span class="n">color</span> <span class="k">else</span> <span class="n">get_color</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Prepare label</span>
        <span class="k">if</span> <span class="n">enum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use the custom enumeration value</span>
            <span class="n">enum_label</span> <span class="o">=</span> <span class="n">enum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">this_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">enum_label</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">label</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">enum_label</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use the base label with default enumeration (e.g., &quot;Label 0&quot;, &quot;Label 1&quot;)</span>
            <span class="n">this_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No label</span>
            <span class="n">this_label</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Plot single circle</span>
        <span class="n">plot_circle</span><span class="p">(</span>
            <span class="n">circle</span><span class="o">=</span><span class="n">circle</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">this_color</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="n">this_label</span><span class="p">,</span> <span class="n">center_as_o</span><span class="o">=</span><span class="n">center_as_o</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span>
        <span class="p">)</span>

    <span class="c1"># Apply common plot settings</span>
    <span class="n">plot_commons</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="n">hold</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="p">(</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">enum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">))</span></div>


<span class="c1"># ========================== STATISTICAL VISUALIZATION ========================== #</span>


<div class="viewcode-block" id="plot_ratii_histograms">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.plot_ratii_histograms">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">plot_ratii_histograms</span><span class="p">(</span><span class="n">ratii_x</span><span class="p">,</span> <span class="n">ratii_y</span><span class="p">,</span> <span class="n">ratii_r</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots histograms for the ratii_x, ratii_y, and ratii_r values.</span>

<span class="sd">    Args:</span>
<span class="sd">        ratii_x (np.ndarray): NumPy array of ratio_x values.</span>
<span class="sd">        ratii_y (np.ndarray): NumPy array of ratio_y values.</span>
<span class="sd">        ratii_r (np.ndarray): NumPy array of ratio_r values.</span>
<span class="sd">        bins (int): Number of bins for the histograms.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If any input is not a NumPy array or if the arrays do not have the same length.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Validate that all ratii are numpy arrays</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ratii_x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ratii_y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ratii_r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All inputs must be NumPy arrays.&quot;</span><span class="p">)</span>

    <span class="c1"># Validate that all arrays have the same length</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">ratii_x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ratii_y</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ratii_r</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All ratii arrays must have the same length.&quot;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

    <span class="c1"># Histogram for ratio_x</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">ratii_x</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Ratio X&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Value&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Frequency&quot;</span><span class="p">)</span>

    <span class="c1"># Histogram for ratio_y</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">ratii_y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Ratio Y&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Value&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Frequency&quot;</span><span class="p">)</span>

    <span class="c1"># Histogram for ratio_r</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">ratii_r</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Ratio R&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Value&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Frequency&quot;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<span class="c1"># ========================== CLUSTER INSPECTION ========================== #</span>

<div class="viewcode-block" id="show_dictionary">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.show_dictionary">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">show_dictionary</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
                   <span class="n">cluster_keys</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                   <span class="n">title</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">plt_points</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                   <span class="n">plt_circles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                   <span class="n">prt_circles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="n">hold</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the clusters from a cluster dictionary with enhanced noise handling.</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster_dict (dict): The cluster dictionary created by `create_cluster_dict`</span>
<span class="sd">        cluster_keys (iterable): Keys of clusters to plot</span>
<span class="sd">        title (str, optional): Title of the plot</span>
<span class="sd">        plot_points (bool): Whether to plot the points</span>
<span class="sd">        plot_circles (bool): Whether to plot fitted circles</span>
<span class="sd">        hold (bool): Whether to hold the plot</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If input types are incorrect</span>
<span class="sd">        ValueError: If cluster data is malformed</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Input validation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cluster_dict must be a dictionary&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cluster_keys</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cluster_keys must be iterable&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;title must be a string or None&quot;</span><span class="p">)</span>

    <span class="c1"># sort cluster keys (noise plotted first)</span>
    <span class="n">cluster_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cluster_keys</span><span class="p">)</span>

    <span class="c1"># print circles</span>
    <span class="k">if</span> <span class="n">prt_circles</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Fitted Circles&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">cluster_keys</span><span class="p">:</span>
            <span class="n">cluster</span> <span class="o">=</span> <span class="n">cluster_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="n">print_circle</span><span class="p">(</span>
                <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">],</span>
                <span class="n">errors</span><span class="o">=</span><span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;errors&#39;</span><span class="p">],</span>
                <span class="n">rmse</span><span class="o">=</span><span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;rmse&#39;</span><span class="p">],</span>
                <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Cluster </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="c1"># Plot points</span>
    <span class="k">if</span> <span class="n">plt_points</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">cluster_keys</span><span class="p">:</span>
            <span class="n">cluster</span> <span class="o">=</span> <span class="n">cluster_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="c1"># Skip plotting points for merged clusters</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="s1">&#39;merged_into&#39;</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># Skip points from clusters merged into others</span>

            <span class="n">points</span> <span class="o">=</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">get_color</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">if</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="s1">&#39;gray&#39;</span>
            <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Cluster </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="s1">&#39;Noise&#39;</span>
            <span class="n">plot_points_base</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

    <span class="c1"># plot circles</span>
    <span class="k">if</span> <span class="n">plt_circles</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">cluster_keys</span><span class="p">:</span>
            <span class="n">cluster</span> <span class="o">=</span> <span class="n">cluster_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="n">color</span> <span class="o">=</span> <span class="n">get_color</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Cluster </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">plot_circle</span><span class="p">(</span>
                <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">],</span>
                <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">,</span>
                <span class="n">center_as_o</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

    <span class="n">plot_commons</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="n">hold</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<span class="c1"># ========================== QUALITY ASSESSMENT ========================== #</span>

<div class="viewcode-block" id="is_a_good_circle">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.is_a_good_circle">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_a_good_circle</span><span class="p">(</span><span class="n">circle</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
                     <span class="n">errors</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
                     <span class="n">rmse</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">r_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
                     <span class="n">r_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
                     <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                     <span class="n">avg_rmse</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines if a circle is &quot;good&quot; based on its parameters and errors.</span>

<span class="sd">    Args:</span>
<span class="sd">        circle: The circle parameters as [cx, cy, r] (NumPy array or tuple)</span>
<span class="sd">        errors: The errors as [err_x, err_y, err_r] (NumPy array or tuple)</span>
<span class="sd">        rmse: The RMSE of the circle fit (NumPy array or float, optional)</span>
<span class="sd">        r_max: Maximum expected radius (default: 0.8)</span>
<span class="sd">        r_min: Minimum expected radius (default: 0.2)</span>
<span class="sd">        alpha: Multiplier for avg_rmse in RMSE condition (default: 3)</span>
<span class="sd">        avg_rmse: Average RMSE across all clusters (required if rmse is provided)</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True if the circle meets all quality conditions, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Input validation</span>
    <span class="k">assert</span> <span class="n">alpha</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;alpha must be positive&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">rmse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">avg_rmse</span> <span class="ow">is</span>
                <span class="kc">None</span><span class="p">),</span> <span class="s2">&quot;avg_rmse must be provided when rmse is given&quot;</span>

    <span class="c1"># Check if radius is None</span>
    <span class="k">if</span> <span class="n">circle</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">circle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">circle</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                                                  <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">errors</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Extract parameters safely</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">circle</span> <span class="c1">#_arr</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">err_r</span> <span class="o">=</span> <span class="n">errors</span> <span class="c1">#_arr</span>

    <span class="c1"># Original conditions</span>
    <span class="n">cond1</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">&lt;</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">r_max</span>
    <span class="n">cond2</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">&gt;</span> <span class="mf">0.75</span> <span class="o">*</span> <span class="n">r_min</span>
    <span class="n">cond3</span> <span class="o">=</span> <span class="n">err_r</span> <span class="o">/</span> <span class="n">radius</span> <span class="o">&lt;</span> <span class="mf">0.5</span>
    <span class="n">conditions</span> <span class="o">=</span> <span class="p">[</span><span class="n">cond1</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">cond3</span><span class="p">]</span>

    <span class="c1"># RMSE validation</span>
    <span class="k">if</span> <span class="n">rmse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">avg_rmse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rmse_val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">rmse</span><span class="p">)</span>
            <span class="n">conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rmse_val</span> <span class="o">&lt;</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">avg_rmse</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span></div>


<span class="c1"># ====================== SYNTHETIC DATA GENERATION ========================== #</span>

<div class="viewcode-block" id="generate_circles">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.generate_circles">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_circles</span><span class="p">(</span><span class="n">num_circles</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                     <span class="n">x_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">x_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
                     <span class="n">y_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">y_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
                     <span class="n">r_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.15</span><span class="p">,</span> <span class="n">r_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a numpy array of circles of the form [x, y, r], where:</span>
<span class="sd">    - (x, y) is the center of the circle.</span>
<span class="sd">    - r is the radius of the circle.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_circles (int): Number of circles to generate.</span>
<span class="sd">        x_min (float): Minimum value for the x-coordinate of the circle centers. Defaults to 0.2.</span>
<span class="sd">        x_max (float): Maximum value for the x-coordinate of the circle centers. Defaults to 0.8.</span>
<span class="sd">        y_min (float): Minimum value for the y-coordinate of the circle centers. Defaults to 0.2.</span>
<span class="sd">        y_max (float): Maximum value for the y-coordinate of the circle centers. Defaults to 0.8.</span>
<span class="sd">        r_min (float): Minimum value for the radius of the circles. Defaults to 0.2.</span>
<span class="sd">        r_max (float): Maximum value for the radius of the circles. Defaults to 0.8.</span>

<span class="sd">    Returns:</span>
<span class="sd">        -np.ndarray: A numpy array of shape (num_circles, 3), where each row is [x, y, r].</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Issues warnings (does not raise exceptions) for:</span>
<span class="sd">          * Negative radii (r_min &lt; 0)</span>
<span class="sd">          * Radii potentially exceeding unit bounds (r_max &gt; 1)</span>
<span class="sd">        - These warnings indicate potential visualization issues but don&#39;t prevent execution</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if the minimum radius is negative</span>
    <span class="k">if</span> <span class="n">r_min</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The minimum radius is negative.&quot;</span>
        <span class="s2">&quot;If you don&#39;t see a ring, it&#39;s because of this.&quot;</span><span class="p">)</span>

    <span class="c1"># Check if the maximum radius is greater than 1</span>
    <span class="k">if</span> <span class="n">r_max</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The maximum radius is too big. &quot;</span>
        <span class="s2">&quot;If you don&#39;t see a ring, it&#39;s because of this.&quot;</span><span class="p">)</span>

    <span class="n">circle_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_circles</span><span class="p">):</span>
        <span class="n">x_circle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
        <span class="n">y_circle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>
        <span class="n">r_circle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">r_min</span><span class="p">,</span> <span class="n">r_max</span><span class="p">)</span>
        <span class="n">circle_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_circle</span><span class="p">,</span> <span class="n">y_circle</span><span class="p">,</span> <span class="n">r_circle</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">circle_list</span><span class="p">)</span></div>


<div class="viewcode-block" id="generate_rings_complete">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.generate_rings_complete">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_rings_complete</span><span class="p">(</span><span class="n">circles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                            <span class="n">points_per_ring</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
                            <span class="n">radius_scatter</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates point clouds representing circular rings with controlled</span>
<span class="sd">        radial and positional scatter.</span>

<span class="sd">    Creates a set of points for each input circle with:</span>
<span class="sd">    1. Radial scatter: Points vary in distance from center</span>
<span class="sd">    2. Positional scatter: Points are randomly displaced in x-y plane</span>

<span class="sd">    Args:</span>
<span class="sd">        circles (np.ndarray): Array of shape (N,3) [x_center, y_center, radius]</span>
<span class="sd">        points_per_ring (int): Number of points per circle</span>
<span class="sd">        radius_scatter (float): Maximum scatter distance in any direction</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Array of (x, y) coordinates with shape (N*points_per_ring, 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_a_good_point</span><span class="p">(</span><span class="n">point</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter function to ensure points are within the bounds [0, 1] for both x and y.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span>

    <span class="c1"># Input validation</span>
    <span class="k">if</span> <span class="n">circles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Circles array must have shape (N,3)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">points_per_ring</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Points per ring must be non-negative&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">radius_scatter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Radius scatter must be non-negative&quot;</span><span class="p">)</span>

    <span class="n">x_coords_all</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">y_coords_all</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">center_x</span><span class="p">,</span> <span class="n">center_y</span><span class="p">,</span> <span class="n">ring_radius</span> <span class="ow">in</span> <span class="n">circles</span><span class="p">:</span>
        <span class="c1"># Generate base points with radial scatter</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">points_per_ring</span><span class="p">)</span>
        <span class="n">radial_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">radius_scatter</span><span class="p">,</span> <span class="n">radius_scatter</span><span class="p">,</span> <span class="n">points_per_ring</span><span class="p">)</span>
        <span class="n">radii</span> <span class="o">=</span> <span class="n">ring_radius</span> <span class="o">+</span> <span class="n">radial_offsets</span>

        <span class="c1"># Convert to Cartesian coordinates</span>
        <span class="n">x_coords</span> <span class="o">=</span> <span class="n">radii</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">+</span> <span class="n">center_x</span>
        <span class="n">y_coords</span> <span class="o">=</span> <span class="n">radii</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">+</span> <span class="n">center_y</span>

        <span class="c1"># Add positional scatter (square with side length = radius_scatter)</span>
        <span class="n">x_coords</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">radius_scatter</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">radius_scatter</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">points_per_ring</span><span class="p">)</span>
        <span class="n">y_coords</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">radius_scatter</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">radius_scatter</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">points_per_ring</span><span class="p">)</span>

        <span class="c1"># Collect coordinates for this ring</span>
        <span class="n">x_coords_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_coords</span><span class="p">)</span>
        <span class="n">y_coords_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_coords</span><span class="p">)</span>

    <span class="c1"># Concatenate all coordinates into single numpy arrays</span>
    <span class="n">x_coords_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">x_coords_all</span><span class="p">)</span>
    <span class="n">y_coords_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">y_coords_all</span><span class="p">)</span>
    <span class="n">all_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x_coords_all</span><span class="p">,</span> <span class="n">y_coords_all</span><span class="p">))</span>

    <span class="c1"># Filter points if a filter function is provided</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">is_a_good_point</span><span class="p">,</span> <span class="n">all_points</span><span class="p">)))</span></div>


<div class="viewcode-block" id="generate_rings_complete_vectorized">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.generate_rings_complete_vectorized">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_rings_complete_vectorized</span><span class="p">(</span><span class="n">circles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                      <span class="n">points_per_ring</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
                                      <span class="n">radius_scatter</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
                                      <span class="n">bounds</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                      <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Vectorized generation of rings with both radial and positional scattering.</span>

<span class="sd">    Creates points with:</span>
<span class="sd">    1. Radial variation: Points vary in distance from center (ring width)</span>
<span class="sd">    2. Positional jitter: Points get random XY displacements (positional noise)</span>

<span class="sd">    Args:</span>
<span class="sd">        circles: Array of shape (N,3) [x_center, y_center, radius]</span>
<span class="sd">        points_per_ring: Points to generate per circle</span>
<span class="sd">        radius_scatter: Maximum scatter distance (both radial and positional)</span>
<span class="sd">        bounds: (x_min, x_max, y_min, y_max) boundaries for filtering</span>
<span class="sd">        verbose: Print generation statistics</span>

<span class="sd">    Returns:</span>
<span class="sd">        Filtered (x,y) points as numpy array of shape (M,2)</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: For invalid inputs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Input validation</span>
    <span class="k">if</span> <span class="n">circles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Circles array must have shape (N,3) with columns [x,y,r]&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">points_per_ring</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Points per ring must be non-negative&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">radius_scatter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Radius scatter must be non-negative&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span> <span class="ow">or</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bounds must be (x_min, x_max, y_min, y_max) with min &lt; max&quot;</span><span class="p">)</span>

    <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">bounds</span>
    <span class="n">n_circles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">circles</span><span class="p">)</span>
    <span class="n">total_points</span> <span class="o">=</span> <span class="n">n_circles</span> <span class="o">*</span> <span class="n">points_per_ring</span>

    <span class="c1"># Base generation (vectorized)</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="p">(</span><span class="n">n_circles</span><span class="p">,</span> <span class="n">points_per_ring</span><span class="p">))</span>

    <span class="c1"># Radial scattering</span>
    <span class="n">radii</span> <span class="o">=</span> <span class="n">circles</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
        <span class="o">-</span><span class="n">radius_scatter</span><span class="p">,</span> <span class="n">radius_scatter</span><span class="p">,</span> <span class="p">(</span><span class="n">n_circles</span><span class="p">,</span> <span class="n">points_per_ring</span><span class="p">))</span>

    <span class="c1"># Convert to Cartesian with centers</span>
    <span class="n">x_base</span> <span class="o">=</span> <span class="n">radii</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">+</span> <span class="n">circles</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">y_base</span> <span class="o">=</span> <span class="n">radii</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">+</span> <span class="n">circles</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="c1"># Positional scattering (jitter in both directions)</span>
    <span class="n">x_jitter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">radius_scatter</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">radius_scatter</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                                <span class="p">(</span><span class="n">n_circles</span><span class="p">,</span> <span class="n">points_per_ring</span><span class="p">))</span>
    <span class="n">y_jitter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">radius_scatter</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">radius_scatter</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                                <span class="p">(</span><span class="n">n_circles</span><span class="p">,</span> <span class="n">points_per_ring</span><span class="p">))</span>

    <span class="c1"># Apply jitter</span>
    <span class="n">x_coords</span> <span class="o">=</span> <span class="n">x_base</span> <span class="o">+</span> <span class="n">x_jitter</span>
    <span class="n">y_coords</span> <span class="o">=</span> <span class="n">y_base</span> <span class="o">+</span> <span class="n">y_jitter</span>

    <span class="c1"># Combine and filter</span>
    <span class="n">all_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x_coords</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">y_coords</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>

    <span class="c1"># Vectorized boundary check</span>
    <span class="n">in_bounds</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">all_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">&amp;</span>
        <span class="p">(</span><span class="n">all_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x_max</span><span class="p">)</span> <span class="o">&amp;</span>
        <span class="p">(</span><span class="n">all_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">y_min</span><span class="p">)</span> <span class="o">&amp;</span>
        <span class="p">(</span><span class="n">all_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">y_max</span><span class="p">))</span>
    <span class="n">filtered_points</span> <span class="o">=</span> <span class="n">all_points</span><span class="p">[</span><span class="n">in_bounds</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">kept_ratio</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_points</span><span class="p">)</span> <span class="o">/</span> <span class="n">total_points</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Generated </span><span class="si">{</span><span class="n">n_circles</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">points_per_ring</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> points&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Kept </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_points</span><span class="p">)</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> points (</span><span class="si">{</span><span class="n">kept_ratio</span><span class="si">:</span><span class="s2">.1%</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Positional scatter: ±</span><span class="si">{</span><span class="n">radius_scatter</span><span class="o">/</span><span class="mi">2</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> units&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Radial scatter: ±</span><span class="si">{</span><span class="n">radius_scatter</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> units</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">filtered_points</span></div>


<span class="c1"># ======================== CIRCLE FITTING ALGORITHMS ====================== #</span>

<div class="viewcode-block" id="fit_circle_to_points">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.fit_circle_to_points">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fit_circle_to_points</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">initial_center</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">initial_radius</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fits a circle to a set of 2D points using least squares optimization.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (np.ndarray): A 2D array of points with shape (N, 2),</span>
<span class="sd">            where N is the number of points.</span>
<span class="sd">        initial_center (Optional[Tuple[float, float]]): Precomputed initial center (c_x, c_y).</span>
<span class="sd">            If provided, it will be used directly.</span>
<span class="sd">        initial_radius (Optional[float]): Precomputed initial radius.</span>
<span class="sd">            If provided, it will be used directly.</span>
<span class="sd">        verbose (bool): If True, prints additional information about the fitting process.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Optional[Tuple[np.ndarray, np.ndarray, float]]: A tuple containing:</span>
<span class="sd">            - [fitted_cx, fitted_cy, fitted_r]: The fitted circle&#39;s center coordinates and radius.</span>
<span class="sd">            - [cx_error, cy_error, radius_error]: The estimated errors in c_x, c_y, and radius.</span>
<span class="sd">            - rmse: The root mean squared error of the fit, calculated as the square root of</span>
<span class="sd">              the residual sum of squares divided by the degrees of freedom.</span>

<span class="sd">        Returns None if the fit fails to converge or if there are not enough points to fit a circle.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the length of the points array is less than MIN_SAMPLES.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">residuals</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the residuals (differences between observed and predicted radii)</span>
<span class="sd">            for the circle fit.</span>

<span class="sd">        Args:</span>
<span class="sd">            params (np.ndarray): A 1D array containing the circle parameters [xc, yc, radius].</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The residuals (observed radii - predicted radius).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_center</span><span class="p">,</span> <span class="n">y_center</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">params</span>  <span class="c1"># Renamed variables to snake_case</span>
        <span class="n">radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_center</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_center</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">radii</span> <span class="o">-</span> <span class="n">radius</span>

    <span class="c1"># Check for minimum number of points to fit a circle</span>
    <span class="n">num_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_points</span> <span class="o">&lt;</span> <span class="n">MIN_SAMPLES</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FIT: Not enough points to fit a circle: </span><span class="si">{</span><span class="n">num_points</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>


    <span class="c1"># Compute initial guess for center as the mean of the points</span>
    <span class="n">center_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> \
                   <span class="k">if</span> <span class="n">initial_center</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">initial_center</span>
    <span class="c1"># Compute initial guess for radius as the mean distance from the center</span>
    <span class="n">radius_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">points</span> <span class="o">-</span> <span class="n">center_guess</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span> \
                   <span class="k">if</span> <span class="n">initial_radius</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">initial_radius</span>
    <span class="n">initial_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">center_guess</span><span class="p">,</span> <span class="n">radius_guess</span><span class="p">)</span>

    <span class="c1"># Perform least squares optimization</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">least_squares</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">)</span>

    <span class="c1"># Return None if fails to converge</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FIT: Fit failed: </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FIT: Status = </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">status</span><span class="si">}</span><span class="s2">, Cost = </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">cost</span><span class="o">/</span><span class="n">num_points</span><span class="si">:</span><span class="s2">.4e</span><span class="si">}</span><span class="s2">, &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="c1"># Extract results</span>
    <span class="n">residuals</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fun</span>  <span class="c1"># Residuals from the fit</span>
    <span class="n">residual_sum_squares</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">residuals</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Renamed variable to snake_case</span>
    <span class="n">degrees_freedom</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_guess</span><span class="p">)</span>  <span class="c1"># Renamed variable to snake_case</span>
    <span class="n">rmse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">residual_sum_squares</span> <span class="o">/</span> <span class="n">degrees_freedom</span><span class="p">)</span>  <span class="c1"># Root mean squared error</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;RMSE = </span><span class="si">{</span><span class="n">rmse</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Compute covariance matrix and parameter errors</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">jacobian</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">jac</span>  <span class="c1"># Renamed variable to snake_case</span>
        <span class="n">jacobian_transpose_jacobian</span> <span class="o">=</span> <span class="n">jacobian</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">jacobian</span>  <span class="c1"># Renamed variable to snake_case</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">jacobian_transpose_jacobian</span>
                                 <span class="p">)</span> <span class="o">&lt;</span> <span class="n">jacobian_transpose_jacobian</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;Singular matrix encountered in covariance calculation.&quot;</span><span class="p">)</span>

        <span class="c1"># Compute covariance matrix using pseudo-inverse to handle potential singularities</span>
        <span class="n">covariance_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">jacobian_transpose_jacobian</span>
                                           <span class="p">)</span> <span class="o">*</span> <span class="n">residual_sum_squares</span> <span class="o">/</span> <span class="n">degrees_freedom</span>
        <span class="n">param_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">covariance_matrix</span><span class="p">))</span>  <span class="c1"># Extract parameter errors</span>

    <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="c1"># Handle cases where covariance calculation fails (e.g., singular matrix)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FIT: Covariance calculation failed due to a singular matrix. Errors set to NaN.&quot;</span><span class="p">)</span>
        <span class="n">param_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FIT: Covariance_matrix =</span><span class="se">\n</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">covariance_matrix</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FIT: Points: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="si">}</span><span class="s2">, Cost: </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">cost</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, RMSE: </span><span class="si">{</span><span class="n">rmse</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">param_errors</span><span class="p">,</span> <span class="n">rmse</span></div>


<div class="viewcode-block" id="fit_circle_to_points_fast">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.fit_circle_to_points_fast">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fit_circle_to_points_fast</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                             <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fast circle fitting using a non-iterative method inspired by Crawford&#39;s algorithm.</span>
<span class="sd">    Maintains the same interface as fit_circle_to_points but uses a different algorithm.</span>

<span class="sd">    Implements the algebraic circle fit method from:</span>
<span class="sd">    jac.F. Crawford, &quot;A non-iterative method for fitting circular arcs to measured points&quot;,</span>
<span class="sd">    Nuclear Instruments and Methods 211 (1983) 223-225:</span>
<span class="sd">    https://www.sciencedirect.com/science/article/pii/0167508783905756?via%3Dihub</span>

<span class="sd">    Args:</span>
<span class="sd">        points (np.ndarray): 2D array of shape (N, 2) containing points to fit</span>
<span class="sd">        initial_center: Ignored (exists for API compatibility)</span>
<span class="sd">        initial_radius: Ignored (exists for API compatibility)</span>
<span class="sd">        verbose (bool): If True, prints debugging information</span>

<span class="sd">    Returns:</span>
<span class="sd">        Optional[Tuple[np.ndarray, np.ndarray, float]]: A tuple containing:</span>
<span class="sd">            - [fitted_cx, fitted_cy, fitted_r]: The fitted circle&#39;s center coordinates and radius.</span>
<span class="sd">            - [cx_error, cy_error, radius_error]: The estimated errors in c_x, c_y, and radius.</span>
<span class="sd">            - rmse: The root mean squared error of the fit, calculated as the square root of</span>
<span class="sd">              the residual sum of squares divided by the degrees of freedom.</span>

<span class="sd">        Returns None if the fit fails to converge or if there are not enough points to fit a circle.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Input Validation</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MIN_SAMPLES</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FIT: Not enough points to fit circle: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">x_coord</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">y_coord</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="c1"># --- Core fitting algorithm ---</span>
    <span class="c1"># Center coordinates relative to centroid</span>
    <span class="n">x_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x_coord</span><span class="p">)</span>
    <span class="n">y_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_coord</span><span class="p">)</span>
    <span class="n">u_mat</span> <span class="o">=</span> <span class="n">x_coord</span> <span class="o">-</span> <span class="n">x_m</span>
    <span class="n">v_mat</span> <span class="o">=</span> <span class="n">y_coord</span> <span class="o">-</span> <span class="n">y_m</span>

    <span class="c1"># Build linear system</span>
    <span class="n">sum_uu</span> <span class="o">=</span> <span class="n">u_mat</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">u_mat</span>  <span class="c1"># Sum of u_mat*u_mat</span>
    <span class="n">sum_vv</span> <span class="o">=</span> <span class="n">v_mat</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">v_mat</span>  <span class="c1"># Sum of v_mat*v_mat</span>
    <span class="n">sum_uv</span> <span class="o">=</span> <span class="n">u_mat</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">v_mat</span>  <span class="c1"># Sum of u_mat*v_mat</span>
    <span class="n">sum_uuu</span> <span class="o">=</span> <span class="n">u_mat</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">u_mat</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># Sum of u_mat^3</span>
    <span class="n">sum_vvv</span> <span class="o">=</span> <span class="n">v_mat</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">v_mat</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># Sum of v_mat^3</span>
    <span class="n">sum_uvv</span> <span class="o">=</span> <span class="n">u_mat</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">v_mat</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># Sum of u_mat*v_mat^2</span>
    <span class="n">sum_vuu</span> <span class="o">=</span> <span class="n">v_mat</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">u_mat</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># Sum of v_mat*u_mat^2</span>

    <span class="c1"># Construct linear system</span>
    <span class="n">mat_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">sum_uu</span><span class="p">,</span> <span class="n">sum_uv</span><span class="p">],</span> <span class="p">[</span><span class="n">sum_uv</span><span class="p">,</span> <span class="n">sum_vv</span><span class="p">]])</span>
    <span class="n">vec_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sum_uuu</span> <span class="o">+</span> <span class="n">sum_uvv</span><span class="p">,</span> <span class="n">sum_vvv</span> <span class="o">+</span> <span class="n">sum_vuu</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Solve for center coordinates (relative to centroid)</span>
        <span class="n">c_u</span><span class="p">,</span> <span class="n">c_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">mat_a</span><span class="p">,</span> <span class="n">vec_b</span><span class="p">)</span>

        <span class="c1"># Transform back to original coordinate system</span>
        <span class="n">c_x</span> <span class="o">=</span> <span class="n">c_u</span> <span class="o">+</span> <span class="n">x_m</span>
        <span class="n">c_y</span> <span class="o">=</span> <span class="n">c_v</span> <span class="o">+</span> <span class="n">y_m</span>

        <span class="c1"># Calculate radius using completed squares formula</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c_u</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c_v</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">sum_uu</span> <span class="o">+</span> <span class="n">sum_vv</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">x_coord</span><span class="p">))</span>

    <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FIT: Matrix solve failed: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1"># Calculate residuals (distances from points to circle)</span>
    <span class="n">residuals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">x_coord</span> <span class="o">-</span> <span class="n">c_x</span><span class="p">,</span> <span class="n">y_coord</span> <span class="o">-</span> <span class="n">c_y</span><span class="p">)</span> <span class="o">-</span> <span class="n">radius</span>
    <span class="n">rss</span> <span class="o">=</span> <span class="n">residuals</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">residuals</span>
    <span class="n">rmse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rss</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_points</span> <span class="o">-</span> <span class="mi">3</span><span class="p">))</span> <span class="c1"># RMSE with 3 DOF lost</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FIT: Cost = </span><span class="si">{</span><span class="n">rss</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="si">:</span><span class="s2">.4e</span><span class="si">}</span><span class="s2">, RMSE = </span><span class="si">{</span><span class="n">rmse</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Build Jacobian matrix for covariance estimation</span>
    <span class="n">d_x</span> <span class="o">=</span> <span class="n">c_x</span> <span class="o">-</span> <span class="n">x_coord</span>
    <span class="n">d_y</span> <span class="o">=</span> <span class="n">c_y</span> <span class="o">-</span> <span class="n">y_coord</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">d_x</span><span class="p">,</span> <span class="n">d_y</span><span class="p">)</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="mf">1e-8</span>  <span class="c1"># Avoid division by zero</span>

    <span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_points</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">jac</span><span class="p">[</span><span class="n">valid</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_x</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span><span class="o">/</span><span class="n">dist</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>  <span class="c1"># ∂r/∂cx</span>
    <span class="n">jac</span><span class="p">[</span><span class="n">valid</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_y</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span><span class="o">/</span><span class="n">dist</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>  <span class="c1"># ∂r/∂cy</span>
    <span class="n">jac</span><span class="p">[</span><span class="n">valid</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>                     <span class="c1"># ∂r/∂r</span>
    <span class="n">jac</span><span class="p">[</span><span class="o">~</span><span class="n">valid</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Handle degenerate cases</span>

    <span class="c1"># Calculate parameter covariance matrix</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">jac</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">jac</span><span class="p">)</span> <span class="o">*</span> <span class="n">rss</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cov</span><span class="p">))</span>
    <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FIT: Covariance calculation failed (singular matrix)&quot;</span><span class="p">)</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FIT: Covariance matrix diagonal: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FIT: Points: </span><span class="si">{</span><span class="n">n_points</span><span class="si">}</span><span class="s2">, RSS: </span><span class="si">{</span><span class="n">rss</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, RMSE: </span><span class="si">{</span><span class="n">rmse</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Package results to match original format</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c_x</span><span class="p">,</span> <span class="n">c_y</span><span class="p">,</span> <span class="n">radius</span><span class="p">]),</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rmse</span></div>


<div class="viewcode-block" id="fit_circles_to_clusters">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.fit_circles_to_clusters">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fit_circles_to_clusters</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">],</span>
                            <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fits circles to all valid clusters in the dictionary using nonlinear least squares.</span>

<span class="sd">    Processes each valid cluster through the following pipeline:</span>
<span class="sd">    1. Validates cluster point distribution</span>
<span class="sd">    2. Performs circle fitting via fit_circle_to_points()</span>
<span class="sd">    3. Updates cluster metadata with fit results</span>
<span class="sd">    4. Marks clusters with failed fits as invalid</span>

<span class="sd">    Parameters:</span>
<span class="sd">        cluster_dict (Dict[int, Dict]): A dictionary of clusters (from create_cluster_dict)</span>
<span class="sd">        verbose (bool): Whether to print verbose output</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (fitted_circles, fitted_errors, fitted_rmses, fitted_labels)</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If cluster_dict has invalid structure</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Validate input dictionary structure</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cluster_dict must be a dictionary&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">cluster_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Skip invalid clusters (noise points)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FCC: Skipping noise cluster </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FCC: Fitting circle to cluster </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Fit circle to cluster points</span>
        <span class="n">fit_results</span> <span class="o">=</span> <span class="n">fit_circle_to_points</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">fit_results</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">FCC: Failed to fit circle to cluster </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">continue</span>

        <span class="c1"># Unpack results</span>
        <span class="n">circle</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rmse</span> <span class="o">=</span> <span class="n">fit_results</span>

        <span class="c1"># Update cluster dictionary</span>
        <span class="n">cluster</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s1">&#39;circle&#39;</span><span class="p">:</span> <span class="n">circle</span><span class="p">,</span>
            <span class="s1">&#39;errors&#39;</span><span class="p">:</span> <span class="n">errors</span><span class="p">,</span>
            <span class="s1">&#39;rmse&#39;</span><span class="p">:</span> <span class="n">rmse</span><span class="p">,</span>
            <span class="s1">&#39;valid&#39;</span><span class="p">:</span> <span class="n">circle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">})</span></div>


<div class="viewcode-block" id="fit_circles_to_clusters_fast">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.fit_circles_to_clusters_fast">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fit_circles_to_clusters_fast</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">],</span>
                            <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rapidly fits circles to clusters using Crawford&#39;s non-iterative algebraic method.</span>

<span class="sd">    Optimized version of fit_circles_to_clusters() that uses direct matrix solving</span>
<span class="sd">    instead of iterative least squares. Provides 5-10x speed improvement for large</span>
<span class="sd">    clusters, but the accuracy is lower.</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster_dict (Dict[int, Dict]): A dictionary of clusters (from create_cluster_dict)</span>
<span class="sd">        verbose (bool): Whether to print verbose output</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (fitted_circles, fitted_errors, fitted_rmses, fitted_labels)</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If cluster_dict has invalid structure</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Validate input dictionary structure</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cluster_dict must be a dictionary&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">cluster_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Skip invalid clusters (noise points)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FCC: Skipping noise cluster </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FCC: Fitting circle to cluster </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Fit circle to cluster points</span>
        <span class="n">fit_results</span> <span class="o">=</span> <span class="n">fit_circle_to_points_fast</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">fit_results</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">FCC: Failed to fit circle to cluster </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">continue</span>

        <span class="c1"># Unpack results</span>
        <span class="n">circle</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rmse</span> <span class="o">=</span> <span class="n">fit_results</span>

        <span class="c1"># Update cluster dictionary</span>
        <span class="n">cluster</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s1">&#39;circle&#39;</span><span class="p">:</span> <span class="n">circle</span><span class="p">,</span>
            <span class="s1">&#39;errors&#39;</span><span class="p">:</span> <span class="n">errors</span><span class="p">,</span>
            <span class="s1">&#39;rmse&#39;</span><span class="p">:</span> <span class="n">rmse</span><span class="p">,</span>
            <span class="s1">&#39;valid&#39;</span><span class="p">:</span> <span class="n">circle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">})</span></div>


<span class="c1"># ======================== CLUSTERING ALGORITHM =========================== #</span>

<div class="viewcode-block" id="filter_labels">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.filter_labels">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">filter_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                 <span class="n">min_points</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Filters a list of labels based on a minimum points threshold.</span>

<span class="sd">    Args:</span>
<span class="sd">        labels: A list of integer labels.</span>
<span class="sd">        min_points: The minimum number of points required for a label to be considered valid.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple containing:</span>
<span class="sd">            - The filtered list of labels with invalid labels set to -1.</span>
<span class="sd">            - The number of valid (surviving) labels.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If labels is not a list or numpy array</span>
<span class="sd">        ValueError: If min_points is negative</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Input validation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Labels must be a list or numpy array&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">min_points</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min_points must be non-negative&quot;</span><span class="p">)</span>

    <span class="c1"># Count occurrences of each label</span>
    <span class="n">label_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

    <span class="c1"># Number of initial clusters</span>
    <span class="n">num_initial_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">label_counts</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initial clusters:&quot;</span><span class="p">,</span> <span class="n">num_initial_clusters</span><span class="p">)</span>

    <span class="c1"># Filter labels based on min_points</span>
    <span class="n">filtered_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="n">label</span> <span class="k">if</span> <span class="n">label_counts</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_points</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span>
    <span class="p">])</span>

    <span class="c1"># Count valid (surviving) labels</span>
    <span class="n">num_valid_labels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">filtered_labels</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Final clusters:  &quot;</span><span class="p">,</span> <span class="n">num_valid_labels</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">filtered_labels</span><span class="p">,</span> <span class="n">num_valid_labels</span></div>


<div class="viewcode-block" id="adaptive_clustering">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.adaptive_clustering">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">adaptive_clustering</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                        <span class="n">min_clusters</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                        <span class="n">max_clusters</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
                        <span class="n">initial_eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
                        <span class="n">min_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
                        <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
                        <span class="n">initial_zoom</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjusts the eps parameter for DBSCAN until the number of clusters is within the desired range.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (np.ndarray): The points to cluster. Must be a 2D array of shape (N, 2).</span>
<span class="sd">        min_clusters (int): Minimum acceptable number of clusters. Must be greater than 0.</span>
<span class="sd">        max_clusters (int): Maximum acceptable number of clusters.</span>
<span class="sd">            Must be greater than min_clusters.</span>
<span class="sd">        initial_eps (float): Starting value for eps. Must be positive.</span>
<span class="sd">        min_samples (int): DBSCAN min_samples parameter. Must be greater than 3.</span>
<span class="sd">        max_iter (int): Maximum number of iterations. Must be greater than 0.</span>
<span class="sd">        initial_zoom (float): Initial zoom factor for adjusting eps. Must be greater than 1.</span>
<span class="sd">        verbose (bool): If True, print detailed progress and results.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray, int]:</span>
<span class="sd">            - labels: Cluster labels for each point.</span>
<span class="sd">            - cluster_count: Number of clusters found (excluding noise).</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If any parameter constraints are violated</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Input validation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Points must be a 2D NumPy array of shape (N, 2).&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">min_clusters</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">max_clusters</span> <span class="o">&lt;</span> <span class="n">min_clusters</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min_clusters must be &gt; 0 and &lt;= than max_clusters.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">initial_eps</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;initial_eps must be positive.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">min_samples</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min_samples must be at least 3.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_iter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;max_iter must be greater than 0.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">initial_zoom</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;initial_zoom must be &gt; 1&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">MIN_DBSCAN_EPS</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;MIN_DBSCAN_EPS must be positive&quot;</span>
    <span class="k">assert</span> <span class="n">MAX_DBSCAN_EPS</span> <span class="o">&gt;</span> <span class="n">MIN_DBSCAN_EPS</span><span class="p">,</span> <span class="s2">&quot;MAX_DBSCAN_EPS must be greater than MIN_DBSCAN_EPS&quot;</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Target clusters: </span><span class="si">{</span><span class="n">min_clusters</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">max_clusters</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Handle zoom direction constants and value</span>
    <span class="n">zoom_dir</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Initial zoom direction (neutral)</span>
    <span class="n">zoom_up</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Zoom direction for increasing eps (merging clusters)</span>
    <span class="n">zoom_down</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Zoom direction for decreasing eps (splitting clusters)</span>
    <span class="n">zoom</span> <span class="o">=</span> <span class="n">initial_zoom</span>  <span class="c1"># Initial zoom factor for adjusting eps</span>

    <span class="n">current_eps</span> <span class="o">=</span> <span class="n">initial_eps</span>  <span class="c1"># Start with the initial eps value</span>
    <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="c1"># Perform DBSCAN clustering with the current eps value</span>
        <span class="n">clustering</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="n">current_eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">min_samples</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">labels_</span>  <span class="c1"># Get cluster labels for each point</span>

        <span class="c1"># cleanup labels and count (real) clusters</span>
        <span class="n">labels</span><span class="p">,</span> <span class="n">cluster_count</span> <span class="o">=</span> <span class="n">filter_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">min_samples</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># Print current iteration details if verbose mode is enabled</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;AC: Iteration </span><span class="si">{</span><span class="n">iteration</span><span class="o">+</span><span class="mi">1</span><span class="si">:</span><span class="s2">2d</span><span class="si">}</span><span class="s2">: current_eps = </span><span class="si">{</span><span class="n">current_eps</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;clusters = </span><span class="si">{</span><span class="n">cluster_count</span><span class="si">:</span><span class="s2">2d</span><span class="si">}</span><span class="s2">, dir = </span><span class="si">{</span><span class="n">zoom_dir</span><span class="si">:</span><span class="s2">2d</span><span class="si">}</span><span class="s2">, zoom = </span><span class="si">{</span><span class="n">zoom</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cluster_count</span> <span class="o">&lt;</span> <span class="n">min_clusters</span><span class="p">:</span>
            <span class="c1"># Too few clusters -&gt; decrease current_eps to split clusters.</span>
            <span class="k">if</span> <span class="n">zoom_dir</span> <span class="o">==</span> <span class="n">zoom_up</span><span class="p">:</span>
                <span class="n">zoom</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">zoom</span> <span class="o">/</span> <span class="p">(</span><span class="n">zoom</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Smoothly adjust zoom factor if direction changes</span>
            <span class="n">current_eps</span> <span class="o">/=</span> <span class="n">zoom</span>
            <span class="n">zoom_dir</span> <span class="o">=</span> <span class="n">zoom_down</span>

        <span class="k">elif</span> <span class="n">cluster_count</span> <span class="o">&gt;</span> <span class="n">max_clusters</span><span class="p">:</span>
            <span class="c1"># Too many clusters -&gt; increase current_eps to merge clusters.</span>
            <span class="k">if</span> <span class="n">zoom_dir</span> <span class="o">==</span> <span class="n">zoom_down</span><span class="p">:</span>
                <span class="n">zoom</span> <span class="o">=</span> <span class="p">(</span><span class="n">zoom</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># Smoothly adjust zoom factor if direction changes</span>
            <span class="n">current_eps</span> <span class="o">*=</span> <span class="n">zoom</span>
            <span class="n">zoom_dir</span> <span class="o">=</span> <span class="n">zoom_up</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Clusters within the desired range, break out of the loop</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">current_eps</span> <span class="o">&lt;</span> <span class="n">MIN_DBSCAN_EPS</span> <span class="ow">or</span> <span class="n">current_eps</span> <span class="o">&gt;</span> <span class="n">MAX_DBSCAN_EPS</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;AC: DBSCAN eps out of range&quot;</span><span class="p">)</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="c1"># Compute number of unclustered points (noise)</span>
        <span class="n">num_unclustered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Print clustering results</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Found </span><span class="si">{</span><span class="n">cluster_count</span><span class="si">}</span><span class="s2"> clusters</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_unclustered</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;There are </span><span class="si">{</span><span class="n">num_unclustered</span><span class="si">}</span><span class="s1"> unclustered points</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;There are NO unclustered points</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>  <span class="c1"># No noise points</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final eps: </span><span class="si">{</span><span class="n">current_eps</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Final eps value used for clustering</span>

        <span class="c1"># Print the number of points in each cluster</span>
        <span class="n">unique_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">unique_labels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># Skip noise points</span>
            <span class="n">cluster_points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">label</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_points</span><span class="p">)</span><span class="si">}</span><span class="s2"> points&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">labels</span><span class="p">,</span> <span class="n">cluster_count</span></div>


<div class="viewcode-block" id="create_cluster_dict">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.create_cluster_dict">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_cluster_dict</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                       <span class="n">labels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">set</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a structured dictionary representation of clustered point data.</span>

<span class="sd">    Organizes points into labeled clusters with metadata for subsequent processing.</span>
<span class="sd">    Handles noise points (label = -1) separately from valid clusters.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (np.ndarray): 2D array of shape (N, 2) containing point coordinates.</span>
<span class="sd">        labels (np.ndarray): 1D array of cluster labels for each point.</span>
<span class="sd">        verbose (bool): If True, prints cluster statistics.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[dict, set] containing:</span>
<span class="sd">            - cluster_dict: Dictionary with cluster metadata</span>
<span class="sd">            - unique_labels: Set of all unique labels found</span>

<span class="sd">    Cluster Dictionary Structure:</span>
<span class="sd">            label: {</span>
<span class="sd">                &#39;labels&#39;: [label],       # Cluster identifier(s)</span>
<span class="sd">                &#39;points&#39;: np.ndarray,    # Array of point coordinates</span>
<span class="sd">                &#39;size&#39;: int,             # Number of points in cluster</span>
<span class="sd">                &#39;circle&#39;: None,          # Will store fitted circle params</span>
<span class="sd">                &#39;errors&#39;: None,          # Will store fitting errors</span>
<span class="sd">                &#39;rmse&#39;: None,            # Will store fitting RMSE</span>
<span class="sd">                &#39;valid&#39;: bool            # False for noise (label=-1)</span>

<span class="sd">            },</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Input validation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Points must be a 2D numpy array of shape (N, 2)&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">labels</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Labels must be a 1D numpy array&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Points and labels must have the same length&quot;</span><span class="p">)</span>

    <span class="c1"># Get all unique labels</span>
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

    <span class="c1"># Build cluster dictionary</span>
    <span class="n">cluster_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># scan all labels</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">unique_labels</span><span class="p">:</span>

        <span class="c1"># Select the points in the cluster</span>
        <span class="n">cluster_points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">label</span><span class="p">]</span>

        <span class="c1"># Number of points in the cluster</span>
        <span class="n">num_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_points</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CCD: Cluster </span><span class="si">{</span><span class="n">label</span><span class="si">:</span><span class="s2">2d</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">num_points</span><span class="si">:</span><span class="s2">4d</span><span class="si">}</span><span class="s2"> points&quot;</span><span class="p">)</span>

        <span class="n">cluster_dict</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">label</span><span class="p">],</span>
            <span class="s1">&#39;points&#39;</span><span class="p">:</span> <span class="n">cluster_points</span><span class="p">,</span>
            <span class="s1">&#39;size&#39;</span>  <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_points</span><span class="p">),</span>
            <span class="s1">&#39;circle&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;errors&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;rmse&#39;</span>  <span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;valid&#39;</span> <span class="p">:</span> <span class="n">label</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="p">}</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Calculate the number of valid clusters (excluding noise) and noise points</span>
        <span class="n">valid_clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">unique_labels</span> <span class="k">if</span> <span class="n">label</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">num_valid_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_clusters</span><span class="p">)</span>
        <span class="n">num_noise_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">unique_labels</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CCD: Found </span><span class="si">{</span><span class="n">num_valid_clusters</span><span class="si">}</span><span class="s2"> clusters and </span><span class="si">{</span><span class="n">num_noise_points</span><span class="si">}</span><span class="s2"> noise points&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cluster_dict</span><span class="p">,</span> <span class="n">unique_labels</span></div>


<div class="viewcode-block" id="filter_fitted_clusters">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.filter_fitted_clusters">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">filter_fitted_clusters</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
                         <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Updates the cluster_dict by filtering fitted circles based on quality criteria.</span>
<span class="sd">    The validity flag in each cluster is updated based on the result of is_a_good_circle.</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster_dict (dict): Cluster dictionary created by create_cluster_dict.</span>
<span class="sd">        verbose (bool): If True, prints details during filtering.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: The updated cluster dictionary with the &#39;valid&#39; field set according to the filtering.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If cluster_dict is not a dictionary or contains invalid types.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Input validation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cluster_dict must be a dictionary&quot;</span><span class="p">)</span>

    <span class="c1"># Calculate average RMSE across clusters that are already valid and have a finite rmse.</span>
    <span class="n">avg_rmse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="n">c</span><span class="p">[</span><span class="s1">&#39;rmse&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cluster_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">c</span><span class="p">[</span><span class="s1">&#39;rmse&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;rmse&#39;</span><span class="p">])</span>
        <span class="p">]))</span>

    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">cluster_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Skip clusters already marked as invalid (e.g. noise) from previous steps.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Cluster </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: Pre-marked invalid. Skipping filtering.&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Retrieve fitted data from the cluster.</span>
        <span class="n">circle</span> <span class="o">=</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">]</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span>
        <span class="n">rmse</span> <span class="o">=</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;rmse&#39;</span><span class="p">]</span>

        <span class="c1"># Check circle quality using average RMSE.</span>
        <span class="n">is_valid</span> <span class="o">=</span> <span class="n">is_a_good_circle</span><span class="p">(</span><span class="n">circle</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rmse</span><span class="p">,</span> <span class="n">avg_rmse</span><span class="o">=</span><span class="n">avg_rmse</span><span class="p">)</span>
        <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_valid</span>

    <span class="k">return</span> <span class="n">cluster_dict</span></div>


<div class="viewcode-block" id="compatible_clusters">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.compatible_clusters">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compatible_clusters</span><span class="p">(</span><span class="n">cdict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">],</span>
                       <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                       <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                       <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines if two clusters are compatible for merging based on their circle fits.</span>

<span class="sd">    Args:</span>
<span class="sd">        cdict (dict): Cluster dictionary containing circle fit information</span>
<span class="sd">        i (int): First cluster ID</span>
<span class="sd">        j (int): Second cluster ID</span>
<span class="sd">        sigma (float): Multiplier for error-based compatibility threshold (default: 3.0)</span>
<span class="sd">        verbose (bool): Whether to print comparison details (default: False)</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True if clusters are compatible for merging, False otherwise</span>

<span class="sd">    Raises:</span>
<span class="sd">        KeyError: If either cluster ID is not found in the dictionary</span>
<span class="sd">        ValueError: If sigma is negative</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Basic input validation</span>
    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cdict</span> <span class="ow">or</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cdict</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster IDs </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> or </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> not found in dictionary&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigma</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sigma must be positive&quot;</span><span class="p">)</span>

    <span class="c1"># Calculate absolute differences between circle Args</span>
    <span class="n">c_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cdict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;circle&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">cdict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;circle&#39;</span><span class="p">])</span>
    <span class="c1"># Sum of errors from both clusters</span>
    <span class="n">e_sum</span> <span class="o">=</span> <span class="n">cdict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">cdict</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span>

    <span class="c1"># Center compatibility check</span>
    <span class="n">center_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c_diff</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">center_threshold</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">e_sum</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

    <span class="c1"># Radius compatibility check</span>
    <span class="n">radius_difference</span> <span class="o">=</span> <span class="n">c_diff</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">radius_threshold</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">e_sum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Determine compatibility</span>
    <span class="n">is_compatible</span> <span class="o">=</span> <span class="n">center_distance</span> <span class="o">&lt;</span> <span class="n">center_threshold</span> <span class="ow">and</span> <span class="n">radius_difference</span> <span class="o">&lt;</span> <span class="n">radius_threshold</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Comparing clusters </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Center distance: </span><span class="si">{</span><span class="n">center_distance</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> (threshold: </span><span class="si">{</span><span class="n">center_threshold</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Radius difference: </span><span class="si">{</span><span class="n">radius_difference</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> (threshold: </span><span class="si">{</span><span class="n">radius_threshold</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_compatible</span><span class="p">:</span>
            <span class="n">reasons</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">center_distance</span> <span class="o">&gt;=</span> <span class="n">center_threshold</span><span class="p">:</span>
                <span class="n">reasons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;center distance </span><span class="si">{</span><span class="n">center_distance</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;&gt;= threshold </span><span class="si">{</span><span class="n">center_threshold</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">radius_difference</span> <span class="o">&gt;=</span> <span class="n">radius_threshold</span><span class="p">:</span>
                <span class="n">reasons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;radius difference </span><span class="si">{</span><span class="n">radius_difference</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;&gt;= threshold </span><span class="si">{</span><span class="n">radius_threshold</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Clusters not merged because: </span><span class="si">{</span><span class="s1">&#39; and &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">reasons</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Clusters are compatible for merging&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">is_compatible</span></div>


<div class="viewcode-block" id="compare_and_merge_clusters">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.compare_and_merge_clusters">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compare_and_merge_clusters</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">],</span>
                               <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
                               <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                               <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merges compatible clusters based on spatial and radial proximity within error bounds.</span>
<span class="sd">    Maintains the cluster with the lowest label as valid and marks others as merged.</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster_dict (Dict[int, Dict]): Dictionary of clusters with keys as cluster</span>
<span class="sd">            IDs and values as cluster parameters</span>
<span class="sd">        sigma (float): Multiplier for error-based compatibility threshold (must be &gt;= 0)</span>
<span class="sd">        verbose (bool): Enable detailed logging</span>

<span class="sd">    Returns:</span>
<span class="sd">        Updated cluster dictionary with merged clusters</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If sigma is negative</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Validate input Args</span>
    <span class="k">if</span> <span class="n">sigma</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sigma must be a non-negative value&quot;</span><span class="p">)</span>

    <span class="c1"># Create working copy to avoid modifying during iteration</span>
    <span class="n">merged_dict</span> <span class="o">=</span> <span class="n">cluster_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># keep track of all merged keys</span>
    <span class="n">processed_keys</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># Get sorted list of valid cluster IDs</span>
    <span class="n">sorted_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cluster_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># scan all keys in sorted order</span>
    <span class="k">for</span> <span class="n">current_key</span> <span class="ow">in</span> <span class="n">sorted_keys</span><span class="p">:</span>
        <span class="n">current_cluster</span> <span class="o">=</span> <span class="n">merged_dict</span><span class="p">[</span><span class="n">current_key</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">current_cluster</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">current_key</span> <span class="ow">in</span> <span class="n">processed_keys</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># keep track of (current) merged keys</span>
        <span class="n">merged_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_key</span><span class="p">]</span>

        <span class="c1"># Compare with other clusters</span>
        <span class="k">for</span> <span class="n">other_key</span> <span class="ow">in</span> <span class="n">sorted_keys</span><span class="p">:</span>
            <span class="n">other_cluster</span> <span class="o">=</span> <span class="n">merged_dict</span><span class="p">[</span><span class="n">other_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">other_cluster</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">other_key</span>\
                <span class="o">&lt;=</span> <span class="n">current_key</span> <span class="ow">or</span> <span class="n">other_key</span> <span class="ow">in</span> <span class="n">processed_keys</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Check compatibility</span>
            <span class="n">are_compatible</span> <span class="o">=</span> <span class="n">compatible_clusters</span><span class="p">(</span><span class="n">merged_dict</span><span class="p">,</span>
                                                 <span class="n">current_key</span><span class="p">,</span> <span class="n">other_key</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Clusters </span><span class="si">{</span><span class="n">current_key</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">other_key</span><span class="si">}</span><span class="s2"> are compatible? </span><span class="si">{</span><span class="n">are_compatible</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Merge if compatible</span>
            <span class="k">if</span> <span class="n">are_compatible</span><span class="p">:</span>
                <span class="n">merged_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span>
                    <span class="n">current_cluster</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">],</span>
                    <span class="n">other_cluster</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span>
                <span class="p">])</span>

                <span class="c1"># Fit new circle to merged points</span>
                <span class="n">fit_result</span> <span class="o">=</span> <span class="n">fit_circle_to_points</span><span class="p">(</span><span class="n">merged_points</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">fit_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">new_circle</span><span class="p">,</span> <span class="n">new_errors</span><span class="p">,</span> <span class="n">new_rmse</span> <span class="o">=</span> <span class="n">fit_result</span>

                <span class="c1"># Only accept merge if RMSE doesn&#39;t increase</span>
                <span class="k">if</span> <span class="n">new_rmse</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">(</span><span class="n">current_cluster</span><span class="p">[</span><span class="s1">&#39;rmse&#39;</span><span class="p">],</span> <span class="n">other_cluster</span><span class="p">[</span><span class="s1">&#39;rmse&#39;</span><span class="p">]):</span>
                    <span class="n">current_cluster</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                        <span class="s1">&#39;points&#39;</span><span class="p">:</span> <span class="n">merged_points</span><span class="p">,</span>
                        <span class="s1">&#39;circle&#39;</span><span class="p">:</span> <span class="n">new_circle</span><span class="p">,</span>
                        <span class="s1">&#39;errors&#39;</span><span class="p">:</span> <span class="n">new_errors</span><span class="p">,</span>
                        <span class="s1">&#39;rmse&#39;</span><span class="p">:</span> <span class="n">new_rmse</span>
                    <span class="p">})</span>

                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Merging clusters: [</span><span class="si">{</span><span class="n">current_key</span><span class="si">}</span><span class="s2">,&quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">other_key</span><span class="si">}</span><span class="s2">] into: cluster </span><span class="si">{</span><span class="n">current_key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New RMSE: </span><span class="si">{</span><span class="n">new_rmse</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1"># append other_key to merged_keys</span>
                    <span class="n">merged_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other_key</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">current_cluster</span><span class="p">[</span><span class="s1">&#39;merged_from&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># PAPO non serve c&#39;è la copia globale all&#39;inizio</span>
            <span class="c1">#merged_dict[current_key] = current_cluster.copy()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current_cluster</span><span class="p">[</span><span class="s1">&#39;merged_from&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_keys</span>

            <span class="c1"># Mark non-primary members as merged</span>
            <span class="k">for</span> <span class="n">member_key</span> <span class="ow">in</span> <span class="n">merged_keys</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">merged_dict</span><span class="p">[</span><span class="n">member_key</span><span class="p">][</span><span class="s1">&#39;valid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">merged_dict</span><span class="p">[</span><span class="n">member_key</span><span class="p">][</span><span class="s1">&#39;merged_into&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_key</span>

        <span class="c1"># add merged_keys to processed set</span>
        <span class="n">processed_keys</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">merged_keys</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">merged_dict</span></div>



<span class="c1"># ======================== POINT EXTRACTION UTILITIES ====================== #</span>

<div class="viewcode-block" id="extract_points">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.extract_points">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">extract_points</span><span class="p">(</span><span class="n">sample_points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                   <span class="n">circle</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                   <span class="n">errors</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                   <span class="n">sigma_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
                   <span class="n">radius_scatter</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
                   <span class="n">context</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cluster&quot;</span><span class="p">,</span>
                   <span class="n">identifier</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects points within dynamic boundaries of a fitted circle based on context.</span>

<span class="sd">    Implements a dual-mode filtering algorithm that:</span>
<span class="sd">    - For &#39;cluster&#39; context: Uses error-bounded selection with fallback scatter</span>
<span class="sd">    - For &#39;outliers&#39; context: Uses statistical deviation-based thresholds</span>

<span class="sd">    Args:</span>
<span class="sd">        sample_points (np.ndarray): Input points to filter</span>
<span class="sd">        circle (np.ndarray): Circle parameters [cx, cy, r]</span>
<span class="sd">        errors (np.ndarray): Circle errors [err_x, err_y, err_r]</span>
<span class="sd">        sigma_threshold (float): Multiplier for error boundaries</span>
<span class="sd">        radius_scatter (float): Fallback radial scatter</span>
<span class="sd">        context (str): Usage context (&#39;cluster&#39; or &#39;outliers&#39;)</span>
<span class="sd">        identifier (Optional[Union[int, str]]): Cluster ID or other identifier for verbose</span>
<span class="sd">        verbose (bool): Show processing details</span>

<span class="sd">    Returns:</span>
<span class="sd">        Boolean mask of selected points</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: For invalid input shapes or values</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Input Validation</span>
    <span class="c1"># Check parameter ranges</span>
    <span class="k">if</span> <span class="n">sigma_threshold</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sigma_threshold must be positive&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">radius_scatter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;radius_scatter cannot be negative&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">context</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span> <span class="s2">&quot;outliers&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;context must be either &#39;cluster&#39; or &#39;outliers&#39;&quot;</span><span class="p">)</span>

     <span class="c1"># Parameter Extraction</span>
    <span class="n">c_x</span><span class="p">,</span> <span class="n">c_y</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">circle</span>
    <span class="n">err_x</span><span class="p">,</span> <span class="n">err_y</span><span class="p">,</span> <span class="n">err_r</span> <span class="o">=</span> <span class="n">errors</span>

    <span class="c1"># Boundary Calculations</span>

    <span class="c1"># This is another way I am doing it, more efficiency but less precision</span>
    <span class="c1"># # Combined center error (Euclidean distance)</span>
    <span class="c1"># center_error = sigma_threshold * np.sqrt(err_x**2 + err_y**2)</span>
    <span class="c1"># # Radius boundary is either: sigma-scaled radius error OR</span>
    <span class="c1"># # minimum radius scatter (whichever is larger)</span>
    <span class="c1"># radius_boundary = max(sigma_threshold * err_r, radius_scatter)</span>

    <span class="c1"># # Total boundary combines center position uncertainty and radius uncertainty</span>
    <span class="c1"># total_boundary = radius_boundary + center_error</span>
    <span class="c1"># # Final selection bounds</span>
    <span class="c1"># lower_bound = radius - total_boundary</span>
    <span class="c1"># upper_bound = radius + total_boundary</span>

    <span class="c1"># This is the old way, less efficiency but more precise</span>
    <span class="k">if</span> <span class="n">context</span> <span class="o">==</span> <span class="s2">&quot;cluster&quot;</span><span class="p">:</span>

        <span class="c1"># Combined center error (Euclidean distance)</span>
        <span class="n">center_error</span> <span class="o">=</span> <span class="n">sigma_threshold</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">err_x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">err_y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Radius boundary is either: sigma-scaled radius error OR</span>
        <span class="c1"># minimum radius scatter (whichever is larger)</span>
        <span class="n">radius_boundary</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sigma_threshold</span> <span class="o">*</span> <span class="n">err_r</span><span class="p">,</span> <span class="n">radius_scatter</span><span class="p">)</span>

        <span class="c1"># Total boundary combines center position uncertainty and radius uncertainty</span>
        <span class="n">total_boundary</span> <span class="o">=</span> <span class="n">radius_boundary</span> <span class="o">+</span> <span class="n">center_error</span>

        <span class="c1"># Final selection bounds</span>
        <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">-</span> <span class="n">total_boundary</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">+</span> <span class="n">total_boundary</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># Calculate distances from the best_ring center</span>
        <span class="c1"># (uncomment to enable outlier-specific thresholds)</span>
        <span class="n">std_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sample_points</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c_x</span><span class="p">,</span> <span class="n">c_y</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">-</span> <span class="n">sigma_threshold</span> <span class="o">*</span> <span class="n">std_dev</span>  <span class="c1"># New lower bound for outlier detection</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">+</span> <span class="n">sigma_threshold</span> <span class="o">*</span> <span class="n">std_dev</span>  <span class="c1"># New upper bound for outlier detection</span>


    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="c1"># Context-aware header</span>
        <span class="k">if</span> <span class="n">context</span> <span class="o">==</span> <span class="s2">&quot;cluster&quot;</span> <span class="ow">and</span> <span class="n">identifier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Evaluating Cluster </span><span class="si">{</span><span class="n">identifier</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">context</span> <span class="o">==</span> <span class="s2">&quot;outliers&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Excluding outliers:&quot;</span><span class="p">)</span>

        <span class="c1"># Common metrics</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  - Center: (</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">c_x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> ± </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">err_x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">,&quot;</span>
              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">c_y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> ± </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">err_y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  - Radius: </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> ± </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">err_r</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Conditional prints</span>
        <span class="k">if</span> <span class="n">context</span> <span class="o">==</span> <span class="s2">&quot;cluster&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  - Center error contribution: ±</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">center_error</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  - Radius error bound (σ×err_r):&quot;</span>
              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">sigma_threshold</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">err_r</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> (σ = </span><span class="si">{</span><span class="n">sigma_threshold</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  - Radius scatter: </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">radius_scatter</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span> <span class="o">==</span> <span class="s2">&quot;cluster&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  - Using boundary: </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">total_boundary</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;(combined center + radius error)&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  - Selection range: [</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">upper_bound</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

     <span class="c1"># Calculate distances from center</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sample_points</span> <span class="o">-</span> <span class="p">[</span><span class="n">c_x</span><span class="p">,</span> <span class="n">c_y</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Create selection mask</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">distances</span> <span class="o">&gt;=</span> <span class="n">lower_bound</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">distances</span> <span class="o">&lt;=</span> <span class="n">upper_bound</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  - Points in boundary: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">context</span> <span class="o">==</span> <span class="s2">&quot;outliers&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  - Points remaining: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="extract_best_ring">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.extract_best_ring">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">extract_best_ring</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
                      <span class="n">sample_points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                      <span class="n">sigma_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
                      <span class="n">radius_scatter</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
                      <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects the best-fitting ring using combined center and radius uncertainties.</span>

<span class="sd">    The function:</span>
<span class="sd">    1. Filters valid clusters from the input dictionary</span>
<span class="sd">    2. Extracts points within error boundaries for each cluster</span>
<span class="sd">    3. Refits circles to the boundary-selected points</span>
<span class="sd">    4. Selects the best candidate based on refined RMSE</span>

<span class="sd">    Args:</span>
<span class="sd">        cluster_dict (Dict[int, Dict[str, Any]]): Dictionary of clusters with keys as cluster IDs</span>
<span class="sd">        sample_points (np.ndarray): All available points (shape [N, 2])</span>
<span class="sd">        sigma_threshold (float): Multiplier for error boundaries</span>
<span class="sd">        radius_scatter (float): Minimum radial scatter allowance</span>
<span class="sd">        verbose (bool): Enable detailed progress output</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple containing:</span>
<span class="sd">        - Points belonging to the best ring (shape [M, 2])</span>
<span class="sd">        - All other points (shape [K, 2])</span>
<span class="sd">        - Tuple of (refined_circle, refined_errors, refined_rmse) for best ring</span>
<span class="sd">        - Cluster ID of the winning ring (or None if no valid rings found)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Input validation with assertions</span>
    <span class="k">assert</span> <span class="n">sigma_threshold</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;sigma_threshold must be non-negative&quot;</span>
    <span class="k">assert</span> <span class="n">radius_scatter</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;radius_scatter must be non-negative&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;cluster_dict must be a dictionary&quot;</span>
    <span class="k">assert</span> <span class="n">sample_points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">sample_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> \
           <span class="s2">&quot;sample_points must be 2D array of shape [N, 2]&quot;</span>

    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Process each cluster in the dictionary</span>
    <span class="k">for</span> <span class="n">cluster_id</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">cluster_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Skip invalid clusters or those missing required data</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> \
        <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;rmse&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Extract cluster parameters</span>
        <span class="n">circle</span> <span class="o">=</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">]</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;errors&#39;</span><span class="p">]</span>
        <span class="n">rmse</span> <span class="o">=</span> <span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;rmse&#39;</span><span class="p">]</span>

        <span class="c1"># Get points within error boundaries using unified extractor</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">extract_points</span><span class="p">(</span>
            <span class="n">sample_points</span><span class="o">=</span><span class="n">sample_points</span><span class="p">,</span>
            <span class="n">circle</span><span class="o">=</span><span class="n">circle</span><span class="p">,</span>
            <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
            <span class="n">sigma_threshold</span><span class="o">=</span><span class="n">sigma_threshold</span><span class="p">,</span>
            <span class="n">radius_scatter</span><span class="o">=</span><span class="n">radius_scatter</span><span class="p">,</span>
            <span class="n">context</span><span class="o">=</span><span class="s2">&quot;cluster&quot;</span><span class="p">,</span>
            <span class="n">identifier</span><span class="o">=</span><span class="n">cluster_id</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="p">)</span>

        <span class="c1"># Get candidate points within boundaries</span>
        <span class="n">candidate_points</span> <span class="o">=</span> <span class="n">sample_points</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="c1"># Skip candidates with too few points</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate_points</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Refit circle using only the boundary-selected points</span>
        <span class="n">fit_result</span> <span class="o">=</span> <span class="n">fit_circle_to_points</span><span class="p">(</span><span class="n">candidate_points</span><span class="p">)</span> <span class="c1">#Remember to change</span>
        <span class="c1">#fit_result = fit_circle_to_points_fast(candidate_points)</span>
        <span class="k">if</span> <span class="n">fit_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># Skip if refitting fails</span>
            <span class="k">continue</span>

        <span class="c1"># Unpack refit results</span>
        <span class="n">new_circle</span><span class="p">,</span> <span class="n">new_errors</span><span class="p">,</span> <span class="n">new_rmse</span> <span class="o">=</span> <span class="n">fit_result</span>

        <span class="c1"># Store candidate information</span>
        <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
            <span class="s1">&#39;cluster_id&#39;</span><span class="p">:</span> <span class="n">cluster_id</span><span class="p">,</span>
            <span class="s1">&#39;mask&#39;</span><span class="p">:</span> <span class="n">mask</span><span class="p">,</span>
            <span class="s1">&#39;original_circle&#39;</span><span class="p">:</span> <span class="n">circle</span><span class="p">,</span>
            <span class="s1">&#39;original_errors&#39;</span><span class="p">:</span> <span class="n">errors</span><span class="p">,</span>
            <span class="s1">&#39;original_rmse&#39;</span><span class="p">:</span> <span class="n">rmse</span><span class="p">,</span>
            <span class="s1">&#39;refined_circle&#39;</span><span class="p">:</span> <span class="n">new_circle</span><span class="p">,</span>
            <span class="s1">&#39;refined_errors&#39;</span><span class="p">:</span> <span class="n">new_errors</span><span class="p">,</span>
            <span class="s1">&#39;refined_rmse&#39;</span><span class="p">:</span> <span class="n">new_rmse</span>
        <span class="p">})</span>

    <span class="c1"># Handle case where no valid candidates were found</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">candidates</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No valid candidates found after boundary filtering&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">sample_points</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1"># Select best candidate with lowest refined RMSE</span>
    <span class="n">best_candidate</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;refined_rmse&#39;</span><span class="p">])</span>
    <span class="n">best_mask</span> <span class="o">=</span> <span class="n">best_candidate</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span>

    <span class="c1"># Split points into ring members and others</span>
    <span class="n">best_points</span> <span class="o">=</span> <span class="n">sample_points</span><span class="p">[</span><span class="n">best_mask</span><span class="p">]</span>
    <span class="n">other_points</span> <span class="o">=</span> <span class="n">sample_points</span><span class="p">[</span><span class="o">~</span><span class="n">best_mask</span><span class="p">]</span>

    <span class="c1"># Package refined fit parameters</span>
    <span class="n">best_fit</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">best_candidate</span><span class="p">[</span><span class="s1">&#39;refined_circle&#39;</span><span class="p">],</span>
        <span class="n">best_candidate</span><span class="p">[</span><span class="s1">&#39;refined_errors&#39;</span><span class="p">],</span>
        <span class="n">best_candidate</span><span class="p">[</span><span class="s1">&#39;refined_rmse&#39;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Verbose output showing comparison between original and refined fits</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Selected cluster </span><span class="si">{</span><span class="n">best_candidate</span><span class="p">[</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
        <span class="n">err_x</span><span class="p">,</span> <span class="n">err_y</span><span class="p">,</span> <span class="n">err_r</span> <span class="o">=</span> <span class="n">best_candidate</span><span class="p">[</span><span class="s1">&#39;original_errors&#39;</span><span class="p">]</span>
        <span class="n">rmse</span> <span class="o">=</span> <span class="n">best_candidate</span><span class="p">[</span><span class="s1">&#39;original_rmse&#39;</span><span class="p">]</span>

        <span class="n">print_circle</span><span class="p">(</span>
            <span class="n">circle</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">best_candidate</span><span class="p">[</span><span class="s1">&#39;original_circle&#39;</span><span class="p">]),</span>
            <span class="n">errors</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">err_x</span><span class="p">,</span> <span class="n">err_y</span><span class="p">,</span> <span class="n">err_r</span><span class="p">]),</span>
            <span class="n">rmse</span><span class="o">=</span><span class="n">best_candidate</span><span class="p">[</span><span class="s1">&#39;original_rmse&#39;</span><span class="p">],</span>
            <span class="n">title</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Original cluster parameters&quot;</span><span class="p">)</span>

        <span class="n">print_circle</span><span class="p">(</span>
            <span class="n">best_fit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">errors</span><span class="o">=</span><span class="n">best_fit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">rmse</span><span class="o">=</span><span class="n">best_fit</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">title</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Refined boundary fit&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Points in ring: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">best_points</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Points excluded: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">other_points</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">best_points</span><span class="p">,</span> <span class="n">other_points</span><span class="p">,</span> <span class="n">best_fit</span><span class="p">,</span> <span class="n">best_candidate</span><span class="p">[</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="exclude_outliers">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.exclude_outliers">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">exclude_outliers</span><span class="p">(</span><span class="n">best_ring</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                     <span class="n">best_fit</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
                     <span class="n">other_points</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                     <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
                         <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                         <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
                     <span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enhanced outlier exclusion using unified extraction methodology with full compatibility.</span>

<span class="sd">    Handles both initial processing (without existing other_points) and iterative refinement.</span>
<span class="sd">    Maintains consistent return types for easy integration in processing pipelines.</span>

<span class="sd">    Args:</span>
<span class="sd">        best_ring (np.ndarray): Points belonging to current ring (shape [N, 2])</span>
<span class="sd">        best_fit (Tuple[np.ndarray, np.ndarray, float]): Tuple containing (circle, errors, rmse)</span>
<span class="sd">        other_points (Optional[np.ndarray]): Optional array of previously excluded points</span>
<span class="sd">            (shape [M, 2])</span>
<span class="sd">        beta (float): Number of standard deviations for outlier threshold (&gt;0)</span>
<span class="sd">        verbose (bool): Print refinement details</span>

<span class="sd">    Returns:</span>
<span class="sd">        new_ring, updated_other_points, new_fit, outliers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Input validation</span>
    <span class="k">assert</span> <span class="n">best_ring</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">best_ring</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Invalid ring shape&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_fit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;Invalid fit format&quot;</span>
    <span class="k">assert</span> <span class="n">beta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Beta must be positive&quot;</span>

    <span class="c1"># Unpack fit parameters</span>
    <span class="n">circle</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rmse</span> <span class="o">=</span> <span class="n">best_fit</span>

    <span class="c1"># Get inlier/outlier mask using unified extractor</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">extract_points</span><span class="p">(</span>
        <span class="n">sample_points</span><span class="o">=</span><span class="n">best_ring</span><span class="p">,</span>
        <span class="n">circle</span><span class="o">=</span><span class="n">circle</span><span class="p">,</span>
        <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
        <span class="n">sigma_threshold</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span>
        <span class="n">context</span><span class="o">=</span><span class="s2">&quot;outliers&quot;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
    <span class="p">)</span>

    <span class="c1"># Split points</span>
    <span class="n">inliers</span> <span class="o">=</span> <span class="n">best_ring</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">outliers</span> <span class="o">=</span> <span class="n">best_ring</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>

    <span class="c1"># Update other points if provided</span>
    <span class="n">updated_other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">other_points</span><span class="p">,</span> <span class="n">outliers</span><span class="p">])</span> <span class="k">if</span> <span class="n">other_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="c1"># Refit circle only if sufficient points remain</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inliers</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">new_circle</span><span class="p">,</span> <span class="n">new_errors</span><span class="p">,</span> <span class="n">new_rmse</span> <span class="o">=</span> <span class="n">fit_circle_to_points</span><span class="p">(</span><span class="n">inliers</span><span class="p">)</span> <span class="c1">#Change to speed up</span>
        <span class="c1">#new_circle, new_errors, new_rmse = fit_circle_to_points_fast(inliers)</span>
        <span class="n">new_fit</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_circle</span><span class="p">,</span> <span class="n">new_errors</span><span class="p">,</span> <span class="n">new_rmse</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Refinement improved RMSE: </span><span class="si">{</span><span class="n">rmse</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> → </span><span class="si">{</span><span class="n">new_rmse</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_fit</span> <span class="o">=</span> <span class="n">best_fit</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Insufficient points for refitting - using original parameters&quot;</span><span class="p">)</span>

    <span class="c1"># Return format depends on other_points presence</span>
    <span class="k">return</span> <span class="n">inliers</span><span class="p">,</span> <span class="n">updated_other</span><span class="p">,</span> <span class="n">new_fit</span><span class="p">,</span> <span class="n">outliers</span></div>


<span class="c1"># ======================== EVALUATION AND COMPARISON ====================== #</span>

<div class="viewcode-block" id="calculate_ratii">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.calculate_ratii">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_ratii</span><span class="p">(</span><span class="n">pairs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
                   <span class="n">original_circles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                   <span class="n">fitted_circles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                   <span class="n">fitted_errors</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                   <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                   <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute error ratios for a given list of fitted pairs, generating detailed messages.</span>

<span class="sd">    Args:</span>
<span class="sd">        pairs (list of tuples): Each tuple is (f_idx, tot_error, o_idx, dist).</span>
<span class="sd">        original_circles (np.ndarray): Array of original circles [x, y, r].</span>
<span class="sd">        fitted_circles (np.ndarray): Array of fitted circles [x, y, r].</span>
<span class="sd">        fitted_errors (np.ndarray): Array of errors [err_x, err_y, err_r].</span>
<span class="sd">        threshold (float): The error threshold multiplier.</span>
<span class="sd">        verbose (bool): If True, print messages as they are constructed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple containing:</span>
<span class="sd">        - List of error ratios [ratio_x, ratio_y, ratio_r] for each pair</span>
<span class="sd">        - List of formatted message strings for each comparison</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Input validation</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s2">&quot;pairs must be a list&quot;</span>
    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fitted_circles</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fitted_errors</span><span class="p">)</span>
            <span class="p">),</span> <span class="s2">&quot;Input arrays must have same length&quot;</span>
    <span class="k">assert</span> <span class="n">threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;threshold must be positive&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">format_ratio</span><span class="p">(</span><span class="n">ratio</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ratio</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ratio</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;∞&quot;</span>

    <span class="n">ratii</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">messages</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Loop over the provided pairs</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">o_idx</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">f_idx</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
        <span class="c1"># Check if disk is undetected</span>
        <span class="k">if</span> <span class="n">dist</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Get data</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="n">original_circles</span><span class="p">[</span><span class="n">o_idx</span><span class="p">]</span>
        <span class="n">fit</span> <span class="o">=</span> <span class="n">fitted_circles</span><span class="p">[</span><span class="n">f_idx</span><span class="p">]</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">fitted_errors</span><span class="p">[</span><span class="n">f_idx</span><span class="p">]</span>

        <span class="c1"># Unpack the values</span>
        <span class="n">orig_x</span><span class="p">,</span> <span class="n">orig_y</span><span class="p">,</span> <span class="n">orig_r</span> <span class="o">=</span> <span class="n">orig</span>
        <span class="n">fit_x</span><span class="p">,</span> <span class="n">fit_y</span><span class="p">,</span> <span class="n">fit_r</span> <span class="o">=</span> <span class="n">fit</span>
        <span class="n">x_err</span><span class="p">,</span> <span class="n">y_err</span><span class="p">,</span> <span class="n">r_err</span> <span class="o">=</span> <span class="n">err</span>

        <span class="c1"># Calculate error ratios (guard against division by zero)</span>
        <span class="n">ratio_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fit_x</span> <span class="o">-</span> <span class="n">orig_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">x_err</span> <span class="k">if</span> <span class="n">x_err</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">ratio_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fit_y</span> <span class="o">-</span> <span class="n">orig_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">y_err</span> <span class="k">if</span> <span class="n">y_err</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">ratio_r</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fit_r</span> <span class="o">-</span> <span class="n">orig_r</span><span class="p">)</span> <span class="o">/</span> <span class="n">r_err</span> <span class="k">if</span> <span class="n">r_err</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="c1"># Append the computed quantities</span>
        <span class="n">ratii</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ratio_x</span><span class="p">,</span> <span class="n">ratio_y</span><span class="p">,</span> <span class="n">ratio_r</span><span class="p">])</span>

        <span class="c1"># Determine overall status using the maximum ratio</span>
        <span class="n">max_ratio</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ratio_x</span><span class="p">,</span> <span class="n">ratio_y</span><span class="p">,</span> <span class="n">ratio_r</span><span class="p">)</span>
        <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;COMPARABLE&quot;</span> <span class="k">if</span> <span class="n">max_ratio</span> <span class="o">&lt;=</span> <span class="n">threshold</span> <span class="k">else</span> <span class="s2">&quot;NOT COMPARABLE&quot;</span>
        <span class="n">status_color</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\033</span><span class="s2">[92m&quot;</span> <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="s2">&quot;COMPARABLE&quot;</span> <span class="k">else</span> <span class="s2">&quot;</span><span class="se">\033</span><span class="s2">[91m&quot;</span>
                        <span class="p">)</span>  <span class="c1"># Green for comparable, red for not</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Comparison Result (Fitted </span><span class="si">{</span><span class="n">f_idx</span><span class="si">}</span><span class="s2"> vs Original </span><span class="si">{</span><span class="n">o_idx</span><span class="si">}</span><span class="s2">):</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;  Original: Center=(</span><span class="si">{</span><span class="n">orig_x</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">orig_y</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">), Radius=</span><span class="si">{</span><span class="n">orig_r</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;  Fitted:   Center=(</span><span class="si">{</span><span class="n">fit_x</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">±</span><span class="si">{</span><span class="n">x_err</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">fit_y</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">±</span><span class="si">{</span><span class="n">y_err</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">), &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Radius=</span><span class="si">{</span><span class="n">fit_r</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">±</span><span class="si">{</span><span class="n">r_err</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;  Error Ratios (σ): X=</span><span class="si">{</span><span class="n">format_ratio</span><span class="p">(</span><span class="n">ratio_x</span><span class="p">)</span><span class="si">}</span><span class="s2">, Y=</span><span class="si">{</span><span class="n">format_ratio</span><span class="p">(</span><span class="n">ratio_y</span><span class="p">)</span><span class="si">}</span><span class="s2">,&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;R=</span><span class="si">{</span><span class="n">format_ratio</span><span class="p">(</span><span class="n">ratio_r</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">status_color</span><span class="si">}{</span><span class="n">status</span><span class="si">}</span><span class="se">\033</span><span class="s2">[0m (Threshold: </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">σ, Max ratio:&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">format_ratio</span><span class="p">(</span><span class="n">max_ratio</span><span class="p">)</span><span class="si">}</span><span class="s2">σ)&quot;</span>
        <span class="p">)</span>
        <span class="n">messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ratii</span><span class="p">,</span> <span class="n">messages</span></div>



<div class="viewcode-block" id="find_fitting_pairs">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.find_fitting_pairs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_fitting_pairs</span><span class="p">(</span><span class="n">original_circles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                     <span class="n">new_best_fit</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
                     <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches original circles with fitted circles based on geometric proximity</span>
<span class="sd">    and relative error thresholds. Computes diagnostic ratios comparing fitted</span>
<span class="sd">    parameters with their uncertainties.</span>

<span class="sd">    The function assigns each original circle to the closest fitted circle</span>
<span class="sd">    whose Euclidean distance is within a given threshold times the total</span>
<span class="sd">    fitting uncertainty.</span>

<span class="sd">    Args:</span>
<span class="sd">        original_circles (np.ndarray): Array of original circles with shape (N, 3),</span>
<span class="sd">        where each row is [x, y, r].</span>
<span class="sd">        new_best_fit (tuple): Tuple of (fitted_circles, fitted_errors, _) where:</span>
<span class="sd">            - fitted_circles (np.ndarray): Array of circles with shape (N, 3), [x, y, r].</span>
<span class="sd">            - fitted_errors (np.ndarray): Array of uncertainties with shape (N, 3),</span>
<span class="sd">            [err_x, err_y, err_r].</span>
<span class="sd">            - _: Placeholder for optional additional data (e.g., RMSEs), unused here.</span>

<span class="sd">        threshold (float): Maximum allowed distance-to-error ratio for a valid match</span>
<span class="sd">            (default: 3).</span>

<span class="sd">        verbose (bool): If True, print diagnostic messages during the matching process.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            - fitted_pairs (np.ndarray): Tuples (orig_idx, dist, fit_idx, err),</span>
<span class="sd">                one per original circle; unmatched ones have dist = np.inf, fit_idx = None.</span>
<span class="sd">            - good_ratii (np.ndarray): Array of shape (M, 3) containing error ratios</span>
<span class="sd">                [ratio_x, ratio_y, ratio_r] for each successfully matched pair.</span>
<span class="sd">            - messages (list of str): Formatted diagnostic strings describing each match.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Validate threshold</span>
    <span class="k">if</span> <span class="n">threshold</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;threshold must be positive&quot;</span><span class="p">)</span>

    <span class="c1"># Unpack the fitted circles and errors</span>
    <span class="n">fitted_circles</span><span class="p">,</span> <span class="n">fitted_errors</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">new_best_fit</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fitted_circles</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fitted_errors</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;fitted_circles and fitted_errors must be numpy arrays&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fitted_circles</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">fitted_errors</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fitted_circles and fitted_errors must have the same shape&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Original Circles ===&quot;</span><span class="p">)</span>
        <span class="n">print_circles</span><span class="p">(</span><span class="n">original_circles</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Original Circles&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Original Circle&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Fitted Circles ===&quot;</span><span class="p">)</span>
        <span class="n">print_circles</span><span class="p">(</span><span class="n">fitted_circles</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">fitted_errors</span><span class="p">,</span>
                      <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Fitted Circles with Errors&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Fitted Circle&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Compute the total error for each fitted circle</span>
    <span class="n">tot_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">fitted_errors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Containers for accepted and rejected pairs</span>
    <span class="n">fitted_pairs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Loop over each original circle #...and assign it by</span>
    <span class="c1"># comparing the center distance against threshold * tot_error.</span>
    <span class="k">for</span> <span class="n">o_idx</span><span class="p">,</span> <span class="n">o_circle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">original_circles</span><span class="p">):</span>

        <span class="c1"># Set initial distance</span>
        <span class="n">min_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">min_f_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">min_tot_err</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Find nearest fitted circle for this original circle</span>
        <span class="k">for</span> <span class="n">f_idx</span><span class="p">,</span> <span class="n">f_circle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fitted_circles</span><span class="p">):</span>

            <span class="c1"># Compute the distance</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">o_circle</span> <span class="o">-</span> <span class="n">f_circle</span><span class="p">)</span>

            <span class="c1"># Compute total error for f_circle</span>
            <span class="n">tot_err</span> <span class="o">=</span> <span class="n">tot_errors</span><span class="p">[</span><span class="n">f_idx</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Original Circle </span><span class="si">{</span><span class="n">o_idx</span><span class="si">}</span><span class="s2"> matching with Fitted </span><span class="si">{</span><span class="n">f_idx</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;with distance </span><span class="si">{</span><span class="n">dist</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> and total error </span><span class="si">{</span><span class="n">tot_err</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance/Error = </span><span class="si">{</span><span class="n">dist</span><span class="o">/</span><span class="n">tot_err</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> (Threshold: </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">80</span><span class="p">)</span>

            <span class="c1"># Check if o_circle and f_circle are compatibles</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">*</span> <span class="n">tot_err</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fitted circle </span><span class="si">{</span><span class="n">f_idx</span><span class="si">}</span><span class="s2">-&gt; REJECTED (Exceeds error threshold)&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="o">*</span><span class="mi">80</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fitted circle </span><span class="si">{</span><span class="n">f_idx</span><span class="si">}</span><span class="s2"> -&gt; VALID (Within error bounds)&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="o">*</span><span class="mi">80</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># If the distance is the minimum found so far</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">min_distance</span><span class="p">:</span>
                <span class="c1"># remember the minimum</span>
                <span class="n">min_distance</span> <span class="o">=</span> <span class="n">dist</span>
                <span class="n">min_f_idx</span> <span class="o">=</span> <span class="n">f_idx</span>
                <span class="n">min_tot_err</span> <span class="o">=</span> <span class="n">tot_err</span>

        <span class="c1"># if min_f_idx != None</span>
        <span class="k">if</span> <span class="n">min_f_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fitted_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">o_idx</span><span class="p">,</span> <span class="n">min_distance</span><span class="p">,</span> <span class="n">min_f_idx</span><span class="p">,</span> <span class="n">min_tot_err</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fitted circle </span><span class="si">{</span><span class="n">min_f_idx</span><span class="si">}</span><span class="s2"> -&gt; SELECTED&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="o">*</span><span class="mi">80</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fitted_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">o_idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Original circle </span><span class="si">{</span><span class="n">o_idx</span><span class="si">}</span><span class="s2"> -&gt; NOT DETECTED (No matching circle)&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="o">*</span><span class="mi">80</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Calculate ratii for accepted (good) circles</span>
    <span class="c1">#good_closest, good_ratii_x, good_ratii_y, good_ratii_r, good_msgs = calculate_ratii(</span>
    <span class="n">good_ratii</span><span class="p">,</span> <span class="n">good_msgs</span> <span class="o">=</span> <span class="n">calculate_ratii</span><span class="p">(</span>
        <span class="n">fitted_pairs</span><span class="p">,</span> <span class="n">original_circles</span><span class="p">,</span> <span class="n">fitted_circles</span><span class="p">,</span> <span class="n">fitted_errors</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>

    <span class="c1"># Build overall messages list – you can interleave or separate as needed.</span>
    <span class="n">messages</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">25</span> <span class="o">+</span> <span class="s2">&quot; ACCEPTED (Good) Fits &quot;</span><span class="o">+</span> <span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">25</span><span class="p">)</span>
    <span class="n">messages</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">good_msgs</span><span class="p">)</span>

    <span class="c1"># Convert lists to numpy arrays where appropriate</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fitted_pairs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">good_ratii</span><span class="p">),</span> <span class="n">messages</span></div>


<div class="viewcode-block" id="find_nearest_circle">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.find_nearest_circle">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_nearest_circle</span><span class="p">(</span><span class="n">initial_circles</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]],</span>
                        <span class="n">circle</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the nearest circle in &#39;initial_circles&#39; to the given &#39;circle&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">        initial_circles (Union[np.ndarray, List[List[float]]]): A list or NumPy array of circles,</span>
<span class="sd">            where each circle is represented as [xc, yc, r].</span>
<span class="sd">        circle (Union[np.ndarray, List[float]]): The circle to find the nearest neighbor for,</span>
<span class="sd">            in the same format [xc, yc, r].</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray, int, float]: A tuple containing:</span>
<span class="sd">            - The nearest circle in &#39;initial_circles&#39; as a NumPy array.</span>
<span class="sd">            - The index of the nearest circle in &#39;initial_circles&#39;.</span>
<span class="sd">            - The Euclidean distance between the given circle and the nearest circle.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If &#39;initial_circles&#39; is empty or if &#39;circle&#39; does not have exactly 3 elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Input validation</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_circles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The list of initial circles cannot be empty.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The circle must be represented &quot;</span>
        <span class="s2">&quot;as a list or array of 3 elements: [xc, yc, r].&quot;</span><span class="p">)</span>

    <span class="c1"># Convert inputs to NumPy arrays for vectorized operations</span>
    <span class="n">initial_circles_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">initial_circles</span><span class="p">)</span>
    <span class="n">circle_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span>

    <span class="c1"># Calculate Euclidean distances between the given circle and all circles in initial_circles</span>
    <span class="c1"># Only consider the (xc, yc) coordinates for distance calculation</span>
    <span class="c1">#distances = np.linalg.norm(initial_circles_np[:, :2] - circle_np[:2], axis=1)</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">initial_circles_np</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">circle_np</span><span class="p">[:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Find the index of the minimum distance</span>
    <span class="n">nearest_circle_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">initial_circles_np</span><span class="p">[</span><span class="n">nearest_circle_index</span><span class="p">],</span>
        <span class="n">nearest_circle_index</span><span class="p">,</span>
        <span class="n">distances</span><span class="p">[</span><span class="n">nearest_circle_index</span><span class="p">]</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="evaluate_fit_comparability">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.evaluate_fit_comparability">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">evaluate_fit_comparability</span><span class="p">(</span><span class="n">original_circles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                             <span class="n">new_best_fit</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                             <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                             <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates fitted circles against original ground truth using error-normalized comparisons.</span>

<span class="sd">    For each fitted circle, finds the closest original circle based on center distance,</span>
<span class="sd">    then calculates error-normalized deviations (in sigmas) for center coordinates and radius.</span>
<span class="sd">    Uses radius difference as tiebreaker when distances are equal.</span>

<span class="sd">    Args:</span>
<span class="sd">        original_circles (np.ndarray): Array of ground truth circles with shape (N,3)</span>
<span class="sd">            where each row contains [x_center, y_center, radius]</span>
<span class="sd">        new_best_fit (Tuple): Contains three arrays:</span>
<span class="sd">            - fitted_circles (np.ndarray): Array of fitted circles with shape (M,3)</span>
<span class="sd">            - fitted_errors (np.ndarray): Array of fitting uncertainties with shape (M,3)</span>
<span class="sd">            - _: Placeholder for optional additional data (unused)</span>
<span class="sd">        threshold (float): Maximum allowed error-normalized deviation (in sigmas) for</span>
<span class="sd">            considering a match valid. Must be &gt; 0. Default: 3</span>
<span class="sd">        verbose (bool): If True, prints detailed comparison results. Default: False</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple containing:</span>
<span class="sd">            - messages (List[str]): Detailed comparison results for each match</span>
<span class="sd">            - closest_fitted (np.ndarray): Array of best matching fitted circles</span>
<span class="sd">            - ratii_x (np.ndarray): Array of x-center deviation ratios (in sigmas)</span>
<span class="sd">            - ratii_y (np.ndarray): Array of y-center deviation ratios (in sigmas)</span>
<span class="sd">            - ratii_r (np.ndarray): Array of radius deviation ratios (in sigmas)</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If threshold is not positive</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Input validation</span>
    <span class="k">if</span> <span class="n">threshold</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Threshold must be positive, got </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Unpack inputs</span>

    <span class="n">fitted_circles</span><span class="p">,</span> <span class="n">fitted_errors</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">new_best_fit</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Original Circles ===&quot;</span><span class="p">)</span>
        <span class="n">print_circles</span><span class="p">(</span><span class="n">original_circles</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Original Circles&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Original Circle&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Fitted Circles ===&quot;</span><span class="p">)</span>
        <span class="n">print_circles</span><span class="p">(</span><span class="n">fitted_circles</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">fitted_errors</span><span class="p">,</span>
                     <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Fitted Circles with Errors&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Fitted Circle&quot;</span><span class="p">)</span>

    <span class="c1"># Create mapping with enhanced tiebreaker logic</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">fit_idx</span><span class="p">,</span> <span class="n">fit_circle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fitted_circles</span><span class="p">):</span>
        <span class="n">orig_idx</span><span class="p">,</span> <span class="n">orig_dist</span> <span class="o">=</span> <span class="n">find_nearest_circle</span><span class="p">(</span><span class="n">original_circles</span><span class="p">,</span> <span class="n">fit_circle</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">orig_r</span> <span class="o">=</span> <span class="n">original_circles</span><span class="p">[</span><span class="n">orig_idx</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">radius_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fit_circle</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">orig_r</span><span class="p">)</span>
        <span class="n">mapping</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">fit_idx</span><span class="p">,</span> <span class="n">orig_idx</span><span class="p">,</span> <span class="n">orig_dist</span><span class="p">,</span> <span class="n">radius_diff</span><span class="p">))</span>

    <span class="c1"># Group by original circle with tiebreaker</span>
    <span class="n">best_matches</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">fit_idx</span><span class="p">,</span> <span class="n">orig_idx</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">radius_diff</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">best_matches</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">orig_idx</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">current</span><span class="p">:</span>
            <span class="c1"># First match for this original</span>
            <span class="n">best_matches</span><span class="p">[</span><span class="n">orig_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;fit_idx&#39;</span><span class="p">:</span> <span class="n">fit_idx</span><span class="p">,</span>
                <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">dist</span><span class="p">,</span>
                <span class="s1">&#39;radius_diff&#39;</span><span class="p">:</span> <span class="n">radius_diff</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Compare with existing match</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">current</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">])</span> <span class="ow">or</span> \
               <span class="p">(</span><span class="n">dist</span> <span class="o">==</span> <span class="n">current</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">radius_diff</span> <span class="o">&lt;</span> <span class="n">current</span><span class="p">[</span><span class="s1">&#39;radius_diff&#39;</span><span class="p">]):</span>
                <span class="n">best_matches</span><span class="p">[</span><span class="n">orig_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;fit_idx&#39;</span><span class="p">:</span> <span class="n">fit_idx</span><span class="p">,</span>
                    <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">dist</span><span class="p">,</span>
                    <span class="s1">&#39;radius_diff&#39;</span><span class="p">:</span> <span class="n">radius_diff</span>
                <span class="p">}</span>

    <span class="c1"># Process matches</span>
    <span class="n">messages</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">closest_fitted</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ratii_x</span><span class="p">,</span> <span class="n">ratii_y</span><span class="p">,</span> <span class="n">ratii_r</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">orig_idx</span><span class="p">,</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">best_matches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">fit_idx</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="s1">&#39;fit_idx&#39;</span><span class="p">]</span>

        <span class="c1"># Get parameters</span>
        <span class="n">orig_x</span><span class="p">,</span> <span class="n">orig_y</span><span class="p">,</span> <span class="n">orig_r</span> <span class="o">=</span> <span class="n">original_circles</span><span class="p">[</span><span class="n">orig_idx</span><span class="p">]</span>
        <span class="n">fit_x</span><span class="p">,</span> <span class="n">fit_y</span><span class="p">,</span> <span class="n">fit_r</span> <span class="o">=</span> <span class="n">fitted_circles</span><span class="p">[</span><span class="n">fit_idx</span><span class="p">]</span>
        <span class="n">x_err</span><span class="p">,</span> <span class="n">y_err</span><span class="p">,</span> <span class="n">r_err</span> <span class="o">=</span> <span class="n">fitted_errors</span><span class="p">[</span><span class="n">fit_idx</span><span class="p">]</span>

        <span class="c1"># Calculate ratios</span>
        <span class="n">ratio_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fit_x</span> <span class="o">-</span> <span class="n">orig_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">x_err</span> <span class="k">if</span> <span class="n">x_err</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">ratio_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fit_y</span> <span class="o">-</span> <span class="n">orig_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">y_err</span> <span class="k">if</span> <span class="n">y_err</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">ratio_r</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fit_r</span> <span class="o">-</span> <span class="n">orig_r</span><span class="p">)</span> <span class="o">/</span> <span class="n">r_err</span> <span class="k">if</span> <span class="n">r_err</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="c1"># Store results</span>
        <span class="n">ratii_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ratio_x</span><span class="p">)</span>
        <span class="n">ratii_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ratio_y</span><span class="p">)</span>
        <span class="n">ratii_r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ratio_r</span><span class="p">)</span>
        <span class="n">closest_fitted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fitted_circles</span><span class="p">[</span><span class="n">fit_idx</span><span class="p">])</span>

        <span class="c1"># Generate message</span>
        <span class="n">max_ratio</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ratio_x</span><span class="p">,</span> <span class="n">ratio_y</span><span class="p">,</span> <span class="n">ratio_r</span><span class="p">)</span>
        <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;COMPARABLE&quot;</span> <span class="k">if</span> <span class="n">max_ratio</span> <span class="o">&lt;=</span> <span class="n">threshold</span> <span class="k">else</span> <span class="s2">&quot;NOT COMPARABLE&quot;</span>

        <span class="c1"># Formatting helper for infinite cases</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">format_ratio</span><span class="p">(</span><span class="n">ratio</span><span class="p">):</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ratio</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;∞&quot;</span>

        <span class="c1"># Create message</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Fitted Circle </span><span class="si">{</span><span class="n">fit_idx</span><span class="si">}</span><span class="s2"> (closest to Original </span><span class="si">{</span><span class="n">orig_idx</span><span class="si">}</span><span class="s2">):</span><span class="se">\n</span><span class="s2">&quot;</span>
               <span class="sa">f</span><span class="s2">&quot;  Radius difference: </span><span class="si">{</span><span class="n">format_ratio</span><span class="p">(</span><span class="n">ratio_r</span><span class="p">)</span><span class="si">}</span><span class="s2">σ; &quot;</span>
               <span class="sa">f</span><span class="s2">&quot;Center differences: x = </span><span class="si">{</span><span class="n">format_ratio</span><span class="p">(</span><span class="n">ratio_x</span><span class="p">)</span><span class="si">}</span><span class="s2">σ, y = </span><span class="si">{</span><span class="n">format_ratio</span><span class="p">(</span><span class="n">ratio_y</span><span class="p">)</span><span class="si">}</span><span class="s2">σ</span><span class="se">\n</span><span class="s2">&quot;</span>
               <span class="sa">f</span><span class="s2">&quot;  =&gt; </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2"> (Threshold: </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">σ, Max ratio: </span><span class="si">{</span><span class="n">format_ratio</span><span class="p">(</span><span class="n">max_ratio</span><span class="p">)</span><span class="si">}</span><span class="s2">σ)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">messages</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">closest_fitted</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ratii_x</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ratii_y</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ratii_r</span><span class="p">)</span>
    <span class="p">)</span></div>


<span class="c1"># ============================ Efficiency Analysis ============================ #</span>

<div class="viewcode-block" id="analyze_ratii_efficiency">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.analyze_ratii_efficiency">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">analyze_ratii_efficiency</span><span class="p">(</span><span class="n">combined_ratii</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                             <span class="n">num_rings</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                             <span class="n">num_seeds</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes efficiency statistics based on the number of detected rings.</span>

<span class="sd">    Args:</span>
<span class="sd">        combined_ratii (np.ndarray): Array of accepted (good) ratii with shape (N, 3).</span>
<span class="sd">        num_rings (int): Number of expected rings per seed.</span>
<span class="sd">        num_seeds (int): Number of independent seeds/runs.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple containing:</span>
<span class="sd">            - total_efficiency (float): Percentage of good rings over total expected.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Validate inputs</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_rings</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">num_rings</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_rings must be a positive integer&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_seeds</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">num_seeds</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_seeds must be a positive integer&quot;</span><span class="p">)</span>

    <span class="c1"># Count detected good rings</span>
    <span class="n">count_good</span> <span class="o">=</span> <span class="n">combined_ratii</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Compute total number of expected rings</span>
    <span class="n">total_expected</span> <span class="o">=</span> <span class="n">num_rings</span> <span class="o">*</span> <span class="n">num_seeds</span>

    <span class="c1"># Compute efficiency as percentage</span>
    <span class="n">total_efficiency</span> <span class="o">=</span> <span class="p">(</span><span class="n">count_good</span> <span class="o">/</span> <span class="n">total_expected</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>

    <span class="c1"># Print diagnostic summary</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Total expected rings: </span><span class="si">{</span><span class="n">total_expected</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Good rings found: </span><span class="si">{</span><span class="n">count_good</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total Efficiency: </span><span class="si">{</span><span class="n">total_efficiency</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">total_efficiency</span></div>


<span class="c1"># ============================ MAIN PROCEDURE ADAPTIVE ============================ #</span>

<div class="viewcode-block" id="main_procedure_adaptive">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.main_procedure_adaptive">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">main_procedure_adaptive</span><span class="p">(</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                           <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
                           <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adaptive procedure for ring detection and circle fitting in 2D point rings.</span>

<span class="sd">    This function implements a multi-step adaptive approach to:</span>
<span class="sd">    1. Generate synthetic ring data</span>
<span class="sd">    2. Perform iterative clustering and circle fitting</span>
<span class="sd">    3. Validate and refine detected rings</span>
<span class="sd">    4. Evaluate results against ground truth</span>

<span class="sd">    Features:</span>
<span class="sd">        - Automatic parameter adjustment</span>
<span class="sd">        - Outlier rejection</span>
<span class="sd">        - Cluster merging</span>
<span class="sd">        - Progressive threshold relaxation</span>

<span class="sd">    Args:</span>
<span class="sd">        verbose (bool): If True, enables detailed progress reporting and visualization</span>
<span class="sd">        seed (int): Random seed for reproducible results</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Array containing the fitting quality metrics (ratii) with shape (n, 3) where:</span>
<span class="sd">            - ratii[:, 0]: x-coordinate deviations</span>
<span class="sd">            - ratii[:, 1]: y-coordinate deviations</span>
<span class="sd">            - ratii[:, 2]: radius deviations</span>

<span class="sd">            Returns empty array if no valid rings found</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Uses adaptive clustering with progressive relaxation</span>
<span class="sd">        - Implements multiple validation checks</span>
<span class="sd">        - Supports iterative refinement</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Set the seed for reproducibility</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="c1"># Record the start time for execution timing</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># --- Step 1: Setup ---</span>
    <span class="c1"># Generate sample circles and print them</span>
    <span class="n">sample_circles</span> <span class="o">=</span> <span class="n">generate_circles</span><span class="p">(</span><span class="n">num_circles</span><span class="o">=</span><span class="n">NUM_RINGS</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="n">X_MIN</span><span class="p">,</span>
                                      <span class="n">x_max</span><span class="o">=</span><span class="n">X_MAX</span><span class="p">,</span> <span class="n">y_min</span><span class="o">=</span><span class="n">Y_MIN</span><span class="p">,</span> <span class="n">y_max</span><span class="o">=</span><span class="n">Y_MAX</span><span class="p">,</span>
                                      <span class="n">r_min</span><span class="o">=</span><span class="n">R_MIN</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="n">R_MAX</span><span class="p">)</span>
    <span class="n">original_circles</span> <span class="o">=</span> <span class="n">sample_circles</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Generate sample points from circles</span>
    <span class="n">sample_points</span> <span class="o">=</span> <span class="n">generate_rings_complete_vectorized</span><span class="p">(</span><span class="n">circles</span><span class="o">=</span><span class="n">sample_circles</span><span class="p">,</span>
                                   <span class="n">points_per_ring</span><span class="o">=</span><span class="n">POINTS_PER_RING</span><span class="p">,</span>
                                   <span class="n">radius_scatter</span><span class="o">=</span><span class="n">RADIUS_SCATTER</span><span class="p">)</span>
    <span class="n">original_points</span> <span class="o">=</span> <span class="n">sample_points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="c1"># Plot the original circles and points</span>
        <span class="n">plot_circles</span><span class="p">(</span><span class="n">sample_circles</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Original Circles&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Original Circle&quot;</span><span class="p">)</span>
        <span class="n">plot_points_base</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Sample Data&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Sample Data&quot;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">found_rings</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># To store refined ring parameters</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Initialize iteration counter</span>

    <span class="c1"># Sigma threshold for ring extraction</span>
    <span class="n">sigma_threshold</span> <span class="o">=</span> <span class="n">SIGMA_THRESHOLD</span>

    <span class="c1"># Flag to control breaking out of both loops</span>
    <span class="n">stop_outer_loop</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Initial clustering constraints</span>
    <span class="n">min_clusters</span> <span class="o">=</span> <span class="n">MIN_CLUSTERS</span>  <span class="c1"># Minimum number of clusters to find</span>
    <span class="n">max_clusters</span> <span class="o">=</span> <span class="n">MAX_CLUSTERS</span>  <span class="c1"># Maximum number of clusters to find</span>
    <span class="n">min_samples</span> <span class="o">=</span> <span class="n">MIN_SAMPLES</span>    <span class="c1"># Minimum samples for each cluster</span>

    <span class="c1"># Main loop to fit circles to the points</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MIN_SAMPLES</span> <span class="o">*</span> <span class="n">MIN_CLUSTERS_PER_RING</span> <span class="o">*</span> <span class="mf">1.5</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stop_outer_loop</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Iteration </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">iteration</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sample points remaining: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_points</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">plot_points</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Remaining Points&quot;</span><span class="p">,</span>
                        <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Remaining sample points&quot;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># --- Step 2: Try Direct Fit ---</span>
        <span class="n">fit_result</span> <span class="o">=</span> <span class="n">fit_circle_to_points_fast</span><span class="p">(</span><span class="n">sample_points</span><span class="p">)</span>
        <span class="n">circle</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rmse</span> <span class="o">=</span> <span class="n">fit_result</span>

        <span class="c1"># Check if the circle is good</span>
        <span class="k">if</span> <span class="n">is_a_good_circle</span><span class="p">(</span>
            <span class="n">circle</span><span class="o">=</span><span class="n">circle</span><span class="p">,</span>
            <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
            <span class="n">r_max</span><span class="o">=</span><span class="n">R_MAX</span><span class="p">,</span>
            <span class="n">r_min</span><span class="o">=</span><span class="n">R_MIN</span><span class="p">,</span>
            <span class="n">rmse</span><span class="o">=</span><span class="n">rmse</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="n">avg_rmse</span><span class="o">=</span><span class="n">RADIUS_SCATTER</span> <span class="c1"># Use RADIUS_SCATTER as the reference for avg_rmse</span>
        <span class="p">):</span>
            <span class="c1"># Refine fit by excluding outliers</span>
            <span class="n">best_ring</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">best_fit</span><span class="p">,</span> <span class="n">outliers</span> <span class="o">=</span> <span class="n">exclude_outliers</span><span class="p">(</span>
                <span class="n">best_ring</span><span class="o">=</span><span class="n">sample_points</span><span class="p">,</span>
                <span class="n">best_fit</span><span class="o">=</span><span class="n">fit_result</span><span class="p">,</span>
                <span class="n">beta</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
            <span class="p">)</span>

            <span class="c1">#Unpack and store the results</span>
            <span class="n">circle</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rmse</span> <span class="o">=</span> <span class="n">best_fit</span>
            <span class="n">found_rings</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
                <span class="n">circle</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">circle</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">circle</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>  <span class="c1"># x, y, r</span>
                <span class="n">errors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">errors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">errors</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>  <span class="c1"># err_x, err_y, err_r</span>
                <span class="n">rmse</span>
            <span class="p">])</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;All points fitted. Stopping.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1">#Step 1: Print the fitted circle</span>
                <span class="n">print_circle</span><span class="p">(</span><span class="n">circle</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Fitted circle&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span> <span class="n">rmse</span><span class="o">=</span><span class="n">rmse</span><span class="p">,</span>
                            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Direct Fit Circle&quot;</span><span class="p">)</span>

                <span class="c1"># Step 2: Plot the best ring points in red</span>
                <span class="n">plot_points_base</span><span class="p">(</span><span class="n">best_ring</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Best Ring&quot;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Step 3: Plot outliers in blue if they exist</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outliers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">plot_points_base</span><span class="p">(</span><span class="n">outliers</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Outliers&quot;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Step 4: Plot the fitted circle in green</span>
                <span class="n">plot_circle</span><span class="p">(</span><span class="n">circle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;solid&quot;</span><span class="p">,</span>
                            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Fitted Circle&quot;</span><span class="p">,</span> <span class="n">center_as_o</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">break</span>  <span class="c1"># Exit loop if good direct fit found</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="c1"># Provide detailed feedback on why the circle is not good</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Not all points fitted. Continuing.&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  - RMSE: </span><span class="si">{</span><span class="n">rmse</span><span class="si">}</span><span class="s2">, while the threshold is &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">RADIUS_SCATTER</span><span class="si">}</span><span class="s2"> (alpha * RADIUS_SCATTER)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># --- Step 3: Adaptive Clustering ---</span>
        <span class="n">retry_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_retries</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># Maximum number of retries</span>

        <span class="k">while</span> <span class="n">retry_count</span> <span class="o">&lt;</span> <span class="n">max_retries</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stop_outer_loop</span><span class="p">:</span>
            <span class="n">retry_count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Perform adaptive clustering</span>
            <span class="n">cluster_labels</span><span class="p">,</span> <span class="n">cluster_count</span> <span class="o">=</span> <span class="n">adaptive_clustering</span><span class="p">(</span>
                <span class="n">sample_points</span><span class="p">,</span>
                <span class="n">min_clusters</span><span class="o">=</span><span class="n">min_clusters</span><span class="p">,</span>
                <span class="n">max_clusters</span><span class="o">=</span><span class="n">max_clusters</span><span class="p">,</span>
                <span class="n">min_samples</span><span class="o">=</span><span class="n">min_samples</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
            <span class="p">)</span>

            <span class="c1"># If no clusters found, break inner loop</span>
            <span class="k">if</span> <span class="n">cluster_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No clusters found in adaptive clustering</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">stop_outer_loop</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Set flag to stop outer loop</span>
                <span class="k">break</span>

            <span class="c1"># Create and process cluster dictionary</span>
            <span class="n">cluster_dict</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">create_cluster_dict</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

            <span class="c1"># --- Step 4: Fit Circles to Clusters ---</span>
            <span class="n">fit_circles_to_clusters</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

            <span class="c1"># --- Step 5: Filter Clusters ---</span>
            <span class="n">cluster_dict</span> <span class="o">=</span> <span class="n">filter_fitted_clusters</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

            <span class="c1"># Check if any valid clusters remain</span>
            <span class="n">valid_clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cluster_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="p">(</span>
                <span class="n">c</span><span class="p">[</span><span class="s1">&#39;valid&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">c</span><span class="p">[</span><span class="s1">&#39;circle&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_clusters</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">!!!!No good clusters found.Retrying with adjusted parameters&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;(Retry </span><span class="si">{</span><span class="n">retry_count</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">max_retries</span><span class="si">}</span><span class="s2">)...!!!!&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Entering </span><span class="si">{</span><span class="n">retry_count</span><span class="si">}</span><span class="s2">nd level adaptive clustering</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Adjust clustering parameters</span>
                <span class="n">min_samples</span> <span class="o">=</span> <span class="n">MIN_SAMPLES</span> <span class="o">+</span> <span class="n">retry_count</span>  <span class="c1"># Increase min_samples</span>
                <span class="n">min_clusters</span> <span class="o">=</span> <span class="n">max_clusters</span>
                <span class="n">max_clusters</span> <span class="o">+=</span> <span class="n">MAX_CLUSTERS</span> <span class="o">-</span> <span class="n">MIN_CLUSTERS</span>
                <span class="k">continue</span>

            <span class="c1"># --- Step 6: Merge Similar Clusters ---</span>
            <span class="n">cluster_dict</span> <span class="o">=</span> <span class="n">compare_and_merge_clusters</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">,</span>
                                                      <span class="n">sigma</span><span class="o">=</span><span class="n">SIGMA_THRESHOLD_RM</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sigma threshold for ring merging: </span><span class="si">{</span><span class="n">SIGMA_THRESHOLD_RM</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Show the dictionary</span>
                <span class="n">show_dictionary</span><span class="p">(</span>
                    <span class="n">cluster_dict</span><span class="p">,</span>
                    <span class="n">cluster_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
                    <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Merged Clusters (Retry </span><span class="si">{</span><span class="n">retry_count</span><span class="si">}</span><span class="s2"> of the current iteration)&quot;</span><span class="p">,</span>
                    <span class="n">plt_points</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">plt_circles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">prt_circles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">hold</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sigma threshold for best ring extraction: </span><span class="si">{</span><span class="n">sigma_threshold</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># --- Step 7: Extract Best Ring from the Fitted Circles ---</span>
            <span class="n">best_ring</span><span class="p">,</span> <span class="n">other_points</span><span class="p">,</span> <span class="n">best_fit</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">extract_best_ring</span><span class="p">(</span>
                <span class="n">cluster_dict</span><span class="p">,</span>
                <span class="n">sample_points</span><span class="p">,</span>
                <span class="n">sigma_threshold</span><span class="o">=</span><span class="n">sigma_threshold</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">best_ring</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;!!!!No valid ring extracted!!!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Unpack the best fit</span>
            <span class="n">circle</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rmse</span> <span class="o">=</span> <span class="n">best_fit</span>

            <span class="c1"># Check if the initial fit is good before refining</span>
            <span class="k">if</span> <span class="n">is_a_good_circle</span><span class="p">(</span>
                <span class="n">circle</span><span class="o">=</span><span class="n">circle</span><span class="p">,</span>
                <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
                <span class="n">r_max</span><span class="o">=</span><span class="n">R_MAX</span><span class="p">,</span>
                <span class="n">r_min</span><span class="o">=</span><span class="n">R_MIN</span><span class="p">,</span>
                <span class="n">rmse</span><span class="o">=</span><span class="n">rmse</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                <span class="n">avg_rmse</span><span class="o">=</span><span class="n">RADIUS_SCATTER</span>
            <span class="p">):</span>
                <span class="c1"># Refine the best ring fit</span>
                <span class="n">best_ring</span><span class="p">,</span> <span class="n">other_points</span><span class="p">,</span> <span class="n">best_fit</span><span class="p">,</span> <span class="n">outliers</span> <span class="o">=</span> <span class="n">exclude_outliers</span><span class="p">(</span>
                    <span class="n">best_ring</span><span class="o">=</span><span class="n">best_ring</span><span class="p">,</span>
                    <span class="n">other_points</span><span class="o">=</span><span class="n">other_points</span><span class="p">,</span>
                    <span class="n">best_fit</span><span class="o">=</span><span class="n">best_fit</span><span class="p">,</span>
                    <span class="n">beta</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
                <span class="p">)</span>

                <span class="c1">#Unpack the new best fit results</span>
                <span class="n">circle</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rmse</span> <span class="o">=</span> <span class="n">best_fit</span>

                <span class="c1"># Store the results</span>
                <span class="n">found_rings</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
                    <span class="n">circle</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">circle</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">circle</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>  <span class="c1"># x, y, r</span>
                    <span class="n">errors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">errors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">errors</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>   <span class="c1"># err_x, err_y, err_r</span>
                    <span class="n">rmse</span>
                <span class="p">])</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="c1"># Step 1: Print the best fit parameters</span>
                    <span class="n">print_circle</span><span class="p">(</span><span class="n">circle</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span> <span class="n">rmse</span><span class="o">=</span><span class="n">rmse</span><span class="p">,</span>
                                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Refined Fit Circle&quot;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Good Ring Found&quot;</span><span class="p">)</span>

                    <span class="c1"># Step 2: Plot the fitted circle in green</span>
                    <span class="n">plot_circle</span><span class="p">(</span><span class="n">circle</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Fitted circle&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;solid&quot;</span><span class="p">,</span>
                                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Fitted Circle&quot;</span><span class="p">,</span> <span class="n">center_as_o</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="c1"># Step 3: Plot all &#39;other_points&#39; in gray</span>
                    <span class="n">plot_points</span><span class="p">(</span><span class="n">other_points</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Other Points&quot;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="c1"># Step 4: Plot outliers in blue if they exist</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outliers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">plot_points</span><span class="p">(</span><span class="n">outliers</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Outliers&quot;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="c1"># Step 5: Plot the best ring points in red</span>
                    <span class="n">plot_points</span><span class="p">(</span><span class="n">best_ring</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Best Ring&quot;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1"># Update sample points and CONTINUE processing</span>
                <span class="n">sample_points</span> <span class="o">=</span> <span class="n">other_points</span>

                <span class="c1"># Reduce the number of clusters for subsequent iterations</span>
                <span class="n">min_clusters</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">MIN_CLUSTERS_PER_RING</span><span class="p">,</span> <span class="n">min_clusters</span> <span class="o">-</span> <span class="n">MIN_CLUSTERS_PER_RING</span><span class="p">)</span>
                <span class="n">max_clusters</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">MAX_CLUSTERS_PER_RING</span><span class="p">,</span> <span class="n">max_clusters</span> <span class="o">-</span> <span class="n">MAX_CLUSTERS_PER_RING</span><span class="p">)</span>

                <span class="n">sigma_threshold</span> <span class="o">*=</span> <span class="n">S_SCALE</span>  <span class="c1"># Scale the sigma threshold for the next iteration</span>

                <span class="k">break</span>  <span class="c1"># Exit retry loop but continue outer loop</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">!!!Initial fit rejected - trying with relaxed parameters!!!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Adjust parameters for next retry</span>
            <span class="n">min_samples</span> <span class="o">=</span> <span class="n">MIN_SAMPLES</span> <span class="o">+</span> <span class="n">retry_count</span>  <span class="c1"># Increase min_samples</span>
            <span class="n">min_clusters</span> <span class="o">=</span> <span class="n">max_clusters</span>
            <span class="n">max_clusters</span> <span class="o">+=</span> <span class="n">MAX_CLUSTERS</span> <span class="o">-</span> <span class="n">MIN_CLUSTERS</span>

         <span class="c1"># Only break outer loop if we&#39;ve exhausted all retries</span>
        <span class="k">if</span> <span class="n">retry_count</span> <span class="o">&gt;=</span> <span class="n">max_retries</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">!!!!Max retries reached - continuing with remaining points!!!!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="c1"># Prepare for next iteration</span>
        <span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Increment the iteration counter</span>

    <span class="c1"># --- End of Loop ---</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Execution Time: </span><span class="si">{</span><span class="n">end_time</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># --- Evaluate Results ---</span>
    <span class="k">if</span> <span class="n">found_rings</span><span class="p">:</span>
        <span class="c1"># Convert found rings to numpy array and split into:</span>
        <span class="c1"># - fitted_circles: [x, y, r] parameters</span>
        <span class="c1"># - fitted_errors: corresponding uncertainties</span>
        <span class="n">found_rings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">found_rings</span><span class="p">)</span>
        <span class="n">fitted_circles</span> <span class="o">=</span> <span class="n">found_rings</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">fitted_errors</span> <span class="o">=</span> <span class="n">found_rings</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>

        <span class="c1"># Match found circles against original ground truth</span>
        <span class="n">fitted_pairs</span><span class="p">,</span> <span class="n">ratii</span><span class="p">,</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">find_fitting_pairs</span><span class="p">(</span>
            <span class="n">original_circles</span><span class="o">=</span><span class="n">original_circles</span><span class="p">,</span>
            <span class="n">new_best_fit</span><span class="o">=</span><span class="p">(</span><span class="n">fitted_circles</span><span class="p">,</span> <span class="n">fitted_errors</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">threshold</span><span class="o">=</span><span class="n">FITTING_PAIR_TRESHOLD</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="c1"># Print matching diagnostics</span>
            <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">messages</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># Visualize results:</span>
            <span class="c1"># 1. Plot original points as background</span>
            <span class="n">plot_points</span><span class="p">(</span><span class="n">original_points</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Original Points&quot;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fitted_pairs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># 2. If successful matches exist, first print, then plot them</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of fitted pairs: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">fitted_pairs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">fit_circles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fitted_circles</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">f_idx</span><span class="p">)]</span>
                                        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">f_idx</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">fitted_pairs</span> <span class="k">if</span> <span class="n">f_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">])</span>
                <span class="n">plot_circles</span><span class="p">(</span><span class="n">fit_circles</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Fitted Circles vs Sample Points&quot;</span><span class="p">,</span>
                            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Fitted Circle&quot;</span><span class="p">,</span> <span class="n">center_as_o</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># No rings found - return empty array</span>
        <span class="n">ratii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="k">return</span> <span class="n">ratii</span></div>


<span class="c1"># ============================== MAIN PROCEDURE ============================== #</span>

<div class="viewcode-block" id="main_procedure">
<a class="viewcode-back" href="../../RingDetection.html#RingDetectionToolkit.ringdetection.main_procedure">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">main_procedure</span><span class="p">(</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>
                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Main procedure for generating rings, fitting circles, and evaluating results.</span>

<span class="sd">    This function implements the complete workflow for synthetic ring generation,</span>
<span class="sd">    iterative circle fitting, and result evaluation against ground truth.</span>

<span class="sd">    Workflow:</span>
<span class="sd">        1. Generates synthetic ring data with configurable parameters</span>
<span class="sd">        2. Performs adaptive clustering and circle fitting</span>
<span class="sd">        3. Validates and refines detected rings</span>
<span class="sd">        4. Evaluates results against original circles</span>

<span class="sd">    Parameters:</span>
<span class="sd">        verbose (bool): If True, enables detailed progress reporting and visualization.</span>
<span class="sd">            Default: False.</span>
<span class="sd">        seed (int): Random seed for reproducible results. Default: 2.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray, np.ndarray, np.ndarray]: Three arrays containing:</span>
<span class="sd">            - ratii_x: Array of x-coordinate deviation ratios (found/original)</span>
<span class="sd">            - ratii_y: Array of y-coordinate deviation ratios</span>
<span class="sd">            - ratii_r: Array of radius deviation ratios</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If input parameters are of incorrect type:</span>
<span class="sd">            - verbose not a boolean</span>
<span class="sd">            - seed not an integer</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Uses adaptive clustering with progressive relaxation</span>
<span class="sd">        - Implements multiple validation checks at each stage</span>
<span class="sd">        - Visualizations are only shown when verbose=True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Input validation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;verbose must be a boolean&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;seed must be an integer&quot;</span><span class="p">)</span>

    <span class="c1"># Initialize lists to store ratii for this run (will be converted to numpy arrays)</span>
    <span class="n">ratii_x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ratii_y</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ratii_r</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Set the seed for reproducibility</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="c1"># Record the start time for execution timing</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># --- Step 1: Setup ---</span>
    <span class="c1"># Generate sample circles and print them</span>
    <span class="n">sample_circles</span> <span class="o">=</span> <span class="n">generate_circles</span><span class="p">(</span><span class="n">num_circles</span><span class="o">=</span><span class="n">NUM_RINGS</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="n">X_MIN</span><span class="p">,</span>
                                      <span class="n">x_max</span><span class="o">=</span><span class="n">X_MAX</span><span class="p">,</span> <span class="n">y_min</span><span class="o">=</span><span class="n">Y_MIN</span><span class="p">,</span> <span class="n">y_max</span><span class="o">=</span><span class="n">Y_MAX</span><span class="p">,</span>
                                      <span class="n">r_min</span><span class="o">=</span><span class="n">R_MIN</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="n">R_MAX</span><span class="p">)</span>
    <span class="n">original_circles</span> <span class="o">=</span> <span class="n">sample_circles</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Generate sample points from circles</span>
    <span class="n">sample_points</span> <span class="o">=</span> <span class="n">generate_rings_complete</span><span class="p">(</span><span class="n">circles</span><span class="o">=</span><span class="n">sample_circles</span><span class="p">,</span>
                                   <span class="n">points_per_ring</span><span class="o">=</span><span class="n">POINTS_PER_RING</span><span class="p">,</span>
                                   <span class="n">radius_scatter</span><span class="o">=</span><span class="n">RADIUS_SCATTER</span><span class="p">)</span>

    <span class="c1"># Decomment if you want to obtain the results in the written document</span>
    <span class="c1"># sample_points = generate_rings_complete(circles=sample_circles,</span>
    <span class="c1">#                                points_per_ring=POINTS_PER_RING,</span>
    <span class="c1">#                                radius_scatter=RADIUS_SCATTER)</span>

    <span class="n">original_points</span> <span class="o">=</span> <span class="n">sample_points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="c1"># Plot the original circles and points</span>
        <span class="n">plot_circles</span><span class="p">(</span><span class="n">sample_circles</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Original Circles&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Original Circle&quot;</span><span class="p">)</span>
        <span class="n">plot_points_base</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Sample Data&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Sample Data&quot;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">False</span><span class="p">,)</span>

    <span class="n">found_rings</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># To store refined ring parameters</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Initialize iteration counter</span>

    <span class="c1"># Initial clustering constraints</span>
    <span class="n">min_clusters</span> <span class="o">=</span> <span class="n">MIN_CLUSTERS</span>  <span class="c1"># Minimum number of clusters to find</span>
    <span class="n">max_clusters</span> <span class="o">=</span> <span class="n">MAX_CLUSTERS</span>  <span class="c1"># Maximum number of clusters to find</span>

    <span class="c1"># Sigma threshold for ring extraction</span>
    <span class="n">sigma_threshold</span> <span class="o">=</span> <span class="n">SIGMA_THRESHOLD</span>

    <span class="c1"># Main loop to fit circles to the points</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MIN_SAMPLES</span> <span class="o">*</span> <span class="n">MIN_CLUSTERS_PER_RING</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Iteration </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">iteration</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sample points remaining: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_points</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">plot_points</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Remaining Points&quot;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


        <span class="c1"># Fit a circle to the points</span>
        <span class="n">fitted_circle</span><span class="p">,</span> <span class="n">param_errors</span><span class="p">,</span> <span class="n">rmse</span> <span class="o">=</span> <span class="n">fit_circle_to_points</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># If the fit is good (RMSE is low and exists), stop the loop</span>
        <span class="k">if</span> <span class="n">rmse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rmse</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">RADIUS_SCATTER</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;All points fitted. Stopping.&quot;</span><span class="p">)</span>

                <span class="c1"># Plot the fitted circle in green</span>
                <span class="n">plot_circle</span><span class="p">(</span><span class="n">fitted_circle</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Fitted circle&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;solid&quot;</span><span class="p">,</span>
                       <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Fitted Circle&quot;</span><span class="p">,</span> <span class="n">center_as_o</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Plot all the points in red</span>
                <span class="n">plot_points</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span>
                            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Fitted circle for best ring&quot;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Store the fitted circle parameters</span>
            <span class="n">found_rings</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
                <span class="n">fitted_circle</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fitted_circle</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fitted_circle</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>  <span class="c1"># x, y, r</span>
                <span class="n">param_errors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param_errors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">param_errors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>   <span class="c1"># err_x, err_y, err_r</span>
            <span class="p">])</span>

            <span class="k">break</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not all points fitted. Continuing.&quot;</span><span class="p">)</span>

        <span class="c1"># --- Step 2: Adaptive Clustering ---</span>
        <span class="n">cluster_labels</span><span class="p">,</span> <span class="n">cluster_count</span> <span class="o">=</span> <span class="n">adaptive_clustering</span><span class="p">(</span>
            <span class="n">sample_points</span><span class="p">,</span>
            <span class="n">min_clusters</span><span class="o">=</span><span class="n">min_clusters</span><span class="p">,</span>
            <span class="n">max_clusters</span><span class="o">=</span><span class="n">max_clusters</span><span class="p">,</span>
            <span class="n">min_samples</span><span class="o">=</span><span class="n">MIN_SAMPLES</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="p">)</span>

        <span class="c1"># If no clusters are found, stop the loop</span>
        <span class="k">if</span> <span class="n">cluster_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No more clusters found. Stopping.&quot;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="c1"># --- Step 3: Create Cluster Dictionary ---</span>
        <span class="n">cluster_dict</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">create_cluster_dict</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span>
                                              <span class="n">cluster_labels</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># --- Step 4: Fit Circles to Clusters ---</span>
        <span class="n">fit_circles_to_clusters</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># --- Step 5: Filter Clusters ---</span>
        <span class="n">cluster_dict</span> <span class="o">=</span> <span class="n">filter_fitted_clusters</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># --- Step 6: Merge Similar Clusters ---</span>
        <span class="n">cluster_dict</span> <span class="o">=</span> <span class="n">compare_and_merge_clusters</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">,</span>
                                                  <span class="n">sigma</span><span class="o">=</span><span class="n">SIGMA_THRESHOLD_RM</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="c1"># Plot merged clusters</span>
            <span class="n">show_dictionary</span><span class="p">(</span>
                <span class="n">cluster_dict</span><span class="p">,</span>
                <span class="n">cluster_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
                <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Merged Clusters&quot;</span><span class="p">,</span>
                <span class="n">plt_points</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">plt_circles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">prt_circles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">hold</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

        <span class="c1"># --- Step 7: Extract Best Ring ---</span>
        <span class="n">best_points</span><span class="p">,</span> <span class="n">other_points</span><span class="p">,</span> <span class="n">best_fit</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">extract_best_ring</span><span class="p">(</span>
            <span class="n">cluster_dict</span><span class="p">,</span>
            <span class="n">sample_points</span><span class="p">,</span>
            <span class="n">sigma_threshold</span><span class="o">=</span><span class="n">sigma_threshold</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sigma threshold: </span><span class="si">{</span><span class="n">sigma_threshold</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># If no best ring is found, stop the loop</span>
        <span class="k">if</span> <span class="n">best_points</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No more rings detected. Stopping.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="c1"># --- Step 8: Refine Fit on Best Ring ---</span>
        <span class="n">best_ring</span><span class="p">,</span> <span class="n">other_points</span><span class="p">,</span> <span class="n">best_fit</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">exclude_outliers</span><span class="p">(</span>
            <span class="n">best_ring</span><span class="o">=</span><span class="n">best_points</span><span class="p">,</span>
            <span class="n">best_fit</span><span class="o">=</span><span class="n">best_fit</span><span class="p">,</span>
            <span class="n">other_points</span><span class="o">=</span><span class="n">other_points</span><span class="p">,</span>
            <span class="n">beta</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="p">)</span>

        <span class="c1"># Store the refined ring parameters</span>
        <span class="k">if</span> <span class="n">best_fit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">circle</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rmse</span> <span class="o">=</span> <span class="n">best_fit</span>
            <span class="n">found_rings</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
                <span class="n">circle</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">circle</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">circle</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>  <span class="c1"># x, y, r</span>
                <span class="n">errors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">errors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">errors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>   <span class="c1"># err_x, err_y, err_r</span>
            <span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="c1"># Plot the results</span>
            <span class="n">plot_circle</span><span class="p">(</span><span class="n">circle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;solid&quot;</span><span class="p">,</span>
                       <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Fitted Circle&quot;</span><span class="p">,</span> <span class="n">center_as_o</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">plot_points</span><span class="p">(</span><span class="n">other_points</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Other Points&quot;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">plot_points</span><span class="p">(</span><span class="n">best_ring</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Best Ring&quot;</span><span class="p">,</span>
                       <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Fitted Circle for Best Ring&quot;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Prepare for next iteration</span>
        <span class="n">sample_points</span> <span class="o">=</span> <span class="n">other_points</span>
        <span class="n">min_clusters</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_clusters</span> <span class="o">-</span> <span class="n">MIN_CLUSTERS_PER_RING</span><span class="p">)</span>
        <span class="n">max_clusters</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_clusters</span> <span class="o">-</span> <span class="n">MAX_CLUSTERS_PER_RING</span><span class="p">)</span>
        <span class="n">sigma_threshold</span> <span class="o">*=</span> <span class="n">S_SCALE</span>
        <span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># --- End of Loop ---</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Execution Time: </span><span class="si">{</span><span class="n">end_time</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># --- Evaluate Results ---</span>
    <span class="k">if</span> <span class="n">found_rings</span><span class="p">:</span>
        <span class="n">found_rings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">found_rings</span><span class="p">)</span>
        <span class="n">fitted_circles</span> <span class="o">=</span> <span class="n">found_rings</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">fitted_errors</span> <span class="o">=</span> <span class="n">found_rings</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>

        <span class="c1"># Evaluate comparability between fitted and original circles</span>
        <span class="n">messages</span><span class="p">,</span> <span class="n">closest_fitted</span><span class="p">,</span> <span class="n">r_x</span><span class="p">,</span> <span class="n">r_y</span><span class="p">,</span> <span class="n">r_r</span> <span class="o">=</span> <span class="n">evaluate_fit_comparability</span><span class="p">(</span>
            <span class="n">original_circles</span><span class="p">,</span>
            <span class="p">(</span><span class="n">fitted_circles</span><span class="p">,</span> <span class="n">fitted_errors</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>  <span class="c1"># Pack as tuple for new function</span>
            <span class="n">threshold</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="p">)</span>

        <span class="c1"># Stack the ratios into a single (n,3) arraygith</span>
        <span class="n">ratii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">r_x</span><span class="p">,</span> <span class="n">r_y</span><span class="p">,</span> <span class="n">r_r</span><span class="p">))</span>

        <span class="c1"># Print the messages from the evaluate fit comparability</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">messages</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># Plot final results</span>
            <span class="n">plot_points</span><span class="p">(</span><span class="n">original_points</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Original Points&quot;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest_fitted</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">plot_circles</span><span class="p">(</span><span class="n">closest_fitted</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Best Fitted Circles vs Original Points&quot;</span><span class="p">,</span>
                         <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Fitted Circle&quot;</span><span class="p">,</span> <span class="n">center_as_o</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Return empty array with shape (0,3) if rings are not found</span>
        <span class="n">ratii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">ratii</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Alessandro Fiorentino.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>